<!DOCTYPE html>
<html lang="zh-CN">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->


<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Mondobongo" />
<meta name="renderer" content="webkit">
<meta name="google" value="notranslate">



<meta name="description" content="一个写给自己看的刷题记录">
<meta name="keywords" content="置顶">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode刷题记录">
<meta property="og:url" content="https://mondobongoo.github.io/2020/04/02/LeetCode刷题记录/index.html">
<meta property="og:site_name" content="Mondobongo&#39;s Blog">
<meta property="og:description" content="一个写给自己看的刷题记录">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://m.qpic.cn/psc?/V138MMQ83qT5pq/h4SLI6MeeCc7mRdKk01uskDCE8*0CvhXv4YbFx6rpz0V6rKS16mCxdoOmVbmT3hnsVTRm.nzjIpniRz.fJ8Z2c71F41daQSLOi3OJhbIxF8!/b&bo=5gEdAuYBHQIRGS4!&rf=viewer_4&t=5">
<meta property="og:updated_time" content="2021-01-08T06:32:47.716Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode刷题记录">
<meta name="twitter:description" content="一个写给自己看的刷题记录">
<meta name="twitter:image" content="http://m.qpic.cn/psc?/V138MMQ83qT5pq/h4SLI6MeeCc7mRdKk01uskDCE8*0CvhXv4YbFx6rpz0V6rKS16mCxdoOmVbmT3hnsVTRm.nzjIpniRz.fJ8Z2c71F41daQSLOi3OJhbIxF8!/b&bo=5gEdAuYBHQIRGS4!&rf=viewer_4&t=5">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternative" href="/atom.xml" title="Mondobongo&#39;s Blog" type="application/atom+xml">



    <link rel="shortcut icon" href="/img/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>LeetCode刷题记录 | Mondobongo&#39;s Blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/touxiang.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Mondobongo</a></h1>
        </hgroup>

        
        <p class="header-subtitle">最是人间留不住，朱颜辞镜花辞树</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:1014158129@qq.com" title="Email"></a>
                            
                                <a class="fa QQ" href="http://wpa.qq.com/msgrd?v=3&uin=1014158129&site=qq&menu=yes" title="QQ"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分图/">二分图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图论/">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/置顶/">置顶</a></li></ul>
                    </div>
                </section>
                
                
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Mondobongo</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/touxiang.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Mondobongo</a></h1>
            </hgroup>
            
            <p class="header-subtitle">最是人间留不住，朱颜辞镜花辞树</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:1014158129@qq.com" title="Email"></a>
                            
                                <a class="fa QQ" target="_blank" href="http://wpa.qq.com/msgrd?v=3&uin=1014158129&site=qq&menu=yes" title="QQ"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-LeetCode刷题记录" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/02/LeetCode刷题记录/" class="article-date">
      <time datetime="2020-04-02T15:45:51.000Z" itemprop="datePublished">2020-04-02</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      LeetCode刷题记录
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/置顶/">置顶</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
      
          
        <blockquote>
<p>一个写给自己看的刷题记录</p>
</blockquote>
<a id="more"></a>
<p>2020.03. 26</p>
<p>1-Two Sum    题目顺序类别: FirstTime-byTag-Array</p>
<p><strong>随记：</strong><br>习惯了平常的ACM题目，第一次见到LeetCode这种预先给答题格式的题目还有些不知所措……看了一会儿才理解输入是传入函数的参数，输出是函数的返回值。并且如果一个函数类型不是void，只是在循环里直接if判断后return会报错，一定要在函数的末尾写有return语句。除此之外，LeetCode好像不会在题目里给出数据的范围。而且LeetCode不用引入头文件就可以直接使用 <code>max()</code> 这种常见函数，也可以直接使用常见的C++ STL</p>
<p><strong>2020.05.23 补记：</strong><br>今天补了哈希表的做法，发现这种做法是常规思维的一个变式。普通的暴力解法是挨个查找看看是否有符合 <code>A + B = target</code> 的元素；而哈希表的做法是，直接查找是否存在 <code>target - A</code> 这个元素。举个例子，现在社团需要招聘一位大二的学生，目前有一批候选人。普通暴力解法就是候选人挨个单独面试，问“你是不是大二的？”；而哈希表的做法是，直接把所有候选人拉到房间里，然后在这群人面前喊一句“大二的学生请举手！”，通过这种做法以达到“空间换时间”的目的。</p>
<p><strong>收获：</strong></p>
<ul>
<li>本题就写了一个$O(n^2)$的暴力二重循环就过了。</li>
<li>题解里更快的解法是用哈希表，暂时没看，以后再补。(2020.05.23已补)</li>
<li>复习了一下vector的概念、初始化、求元素个数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n);</span><br><span class="line"><span class="comment">//注意要与数组的初始化区分开，千万不要把vec(n)写成了vec[n]</span></span><br><span class="line"><span class="keyword">int</span> vecSize=vec.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i; i&lt;vecSize; i++)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;vec[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分清了Markdown语法的 <code>$行内公式$</code> 和 <code>$$行间公式$$</code></li>
<li>领悟到一个优化代码运行速度的写法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该写法代码运行时间484ms</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++ )</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;nums.size(); j++)</span><br><span class="line"></span><br><span class="line"><span class="comment">//该写法代码运行时间336ms</span></span><br><span class="line"><span class="keyword">int</span> numsSize=nums.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++ )</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;numsSize; j++)</span><br></pre></td></tr></table></figure>
<hr>
<p>2020.04.01</p>
<p>136-Single Number 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>一个数组里除了一个数字只出现过一次，其他所有数字都出现了两次，找出这个数字。暴力解很简单，写个二重循环就行了。</p>
<p>但是题目要求”have a linear runtime complexity”, 即要求时间复杂度为$O(n)$。然后我就想到了以前做题的一种处理方法——利用数组，数组元素的下标不再只是一个单纯的序号，而有了实际意义：数组的下标代表着某个数字，元素的内容就代表该数字出现过几次，例如 <code>num[4]=2;</code> 就意味着”数字4出现过2次”。</p>
<p>按照这种思路就写了一遍，交了之后就<strong>Runtime Error</strong>了，根据以往ACM的经验，大概率是<strong>数组越界</strong>了。查看了一下果然是的，因为数组下标不能小于0，所以当输入数据有负数如-1时，数组自然就越界了。</p>
<p>这个时候我就想到了以前使用过的一种C++ STL——map. 这种数据结构类似数组，但是数组的下标只能为自然数，而map的关键字可以是任意类型的数据如int、String等，如果map的关键字类型为int，那么自然就可以用负数了。</p>
<p>接着写啊写，提交了之后发现又变成了 <strong>Time Limit Exceeded</strong> …… 这明显就是程序陷入无限循环了，debug了一会儿，发现是对map进行遍历的while循环里忘了对迭代器进行更新。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">iter=m.begin();</span><br><span class="line"><span class="keyword">while</span>(iter!=m.end())&#123;</span><br><span class="line">  <span class="keyword">if</span>(iter-&gt;second==<span class="number">1</span>)&#123;</span><br><span class="line">    ans=iter-&gt;first;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//此处应该有 iter++;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>究其原因就是我平常用的最多的是for循环，然而我看map相关博文的时候，给出的是我不常用的while 循环，我照着写然后就疏忽了。看来以后还是要用for循环对map进行遍历。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator iter = m.begin(); iter!=m.end(); iter++) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　看了看题解，发现原来我这种”利用数组下标“的方式就是”哈希“。也对，map在Java里就叫做HashMap。</p>
<p><strong>收获：</strong> </p>
<ul>
<li>本题最厉害的一种解法是用 “异或”，任何数和 0 做异或运算，结果仍然是原来的数</li>
<li>当数组下标需要是负数时，就要立刻想到用map</li>
<li><a href="https://www.cnblogs.com/fnlingnzb-learner/p/5833051.html" target="_blank" rel="noopener">学习了map</a>的初始化、插值、遍历等操作</li>
<li>学会了判断map用insert插值是否成功(如果关键字已经在map里就会插入失败)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">pair&lt;<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator,<span class="keyword">bool</span>&gt; Insert_Pair;</span><br><span class="line">Insert_Pair = m.insert(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(nums[i],<span class="number">1</span>));<span class="comment">//获取插入的结果</span></span><br><span class="line"><span class="keyword">if</span>(Insert_Pair.second == <span class="literal">false</span>)&#123; <span class="comment">//如果插入失败了，证明该关键字已在map中</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>2020.04.02</p>
<p>202- Happy Number    题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong></p>
<p>​    </p>
<p><strong>收获：</strong></p>
<hr>
<p>2020.04.03</p>
<p>53-Maximum Subarray 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　最大子数组和，第一眼我感觉像是一个动态规划题，试着构思了一些还真想出来了一个简单的dp推导式，<strong>dp[i]代表以第i个数结尾的“连续子数组的最大和”</strong>。顺着思路写代码，很快就写完了。只不过第一次提交错误，202个样例过了201个，卡在了<code>[-2147483647]</code>，原因是设置max初始值的时候我写的是<code>max=-999</code>，我本来以为这个值已经够小了，没想到数据里给出的更小……随后改为<code>max=dp[0]</code>,代码通过。<br>　　提交后看官方题解，其中有一种就是动态规划，与我的思路完全一致。不过在看别人代码的时候，我发现我代码里有两处可以优化的地方：</p>
<ol>
<li><p>别人的代码里，处理dp数组和更新max值在同一个for循环遍历中进行。而我的代码先for循环一次处理dp数组，再for循环一次更新max值，就显得很蠢。</p>
</li>
<li><p>代码的<strong>空间复杂度</strong>不需要$O(n)$，$O(1)$就足够了。因为dp数组里很多值用过一次后就没用了，可以被覆盖掉。所以额外设置单个变量就行，不用再设置一个一维dp数组。</p>
</li>
</ol>
<p>​<br><strong>收获：</strong></p>
<ul>
<li>学会了一个vector初始化并赋值的方式 <code>vector&lt;int&gt; dp(numsSize,0);</code></li>
<li>在本地IDE测试代码时，又学会了一种vector的初始化方式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b[<span class="number">9</span>]=&#123;<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(b,b+<span class="number">9</span>);</span><br></pre></td></tr></table></figure>
<hr>
<p>2020.04.04</p>
<p>283-Move Zeroes 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　本题乍一看很简单，但是题目中的额外要求”<strong>in-place</strong> without making a copy of the array”,就是说你必须在原地操作，不能使用一个额外的数组。这就有点麻烦了，想了一会儿后我写了个二重for循环，依次交换0和非0元素(有点像冒泡排序那种形式)。提交一次就通过了，但是时间消耗很大，仅超过了17%的提交。<br>​　　看了别人的题解，发现他们的代码时间复杂度都是$O(n)$，使用的方法被称之为“双指针”，参见 <a href="https://leetcode-cn.com/problems/move-zeroes/solution/shuang-zhi-zhen-jiao-huan-yuan-su-by-lo_e/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/move-zeroes/solution/shuang-zhi-zhen-jiao-huan-yuan-su-by-lo_e/</a></p>
<p><strong>收获：</strong></p>
<ul>
<li>学习了“双指针”的思想</li>
</ul>
<hr>
<p>2020.04.05</p>
<p>122-Best Time to Buy and Sell Stock II 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong></p>
<p>　　第一眼看上去感觉有点像是“最长上升子序列”，本来开始准备写dp什么的了，后来发现这题简单到根本用不着dp，直接写几行代码就过了。</p>
<p>　　最精彩的是我交完题后看官方题解，我以为这么简单的题就一种暴力解法，没想到居然还有三种思路。我想我的思路肯定是最简单的，就直接越过前两种简单解法没看，直接去看最后一种解法，没想到最后一种解法就是我的思路。然后我回头看了一眼第一个题解，惊了，我以为我的$O(n)$解法已经够简单粗暴了，第一种题解居然还能写出更暴力$O(n^2)$的代码……(没敢仔细看这种解法，怕影响我智商) 接着又看了看评论区，竟然发现很多人在赞扬第三种解法有多精妙……无语，本质上就是一道非常简单的C语言题目而已。</p>
<p><strong>收获：</strong> 无</p>
<hr>
<p>2020.04.06</p>
<p>49-Group Anagrams    题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong></p>
<p>　　题目第一眼看上去不难，就是如果按纯暴力来做，操作起来可能有点麻烦。这时候我就想到了要不要把每个字母转化成数字，然后用每个单词里每个字母所代表的数字相加，然后来判断这两个单词是否互为anagrams(相同字母异序词)。但是发现无法解决12+14=13+13这种情况，遂放弃。</p>
<p>　　然后我就想到了把对每个单词都进行内部字母排序，比如ate和eat都排序为aet。之后放入一个map里，利用map关键字的唯一性，这样就可以来判断多个单词是否互为anagrams。</p>
<p>　　可是按照这种思路，需要额外写一个string内部排序函数，我觉得有点麻烦。于是我就在想，C++内置了很多非常强大的函数，那么string能不能直接调用一两个函数就直接对内部进行排序呢？查了一下居然真的找到了<a href="https://blog.csdn.net/sinat_34328764/article/details/80088457" target="_blank" rel="noopener">我想要的答案</a> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(str.begin(), str.end());</span><br></pre></td></tr></table></figure>
<p>　　写题的过程中，我发现需要用到“插入”的方式来对vector添加元素，而不是以往<code>vec[i]=0;</code> 这种形式。然后我就突然有一个想法，既然vector和map都能以“插入”的方式赋值，那么vector能不能像map一样在初始化的时候不规定大小呢？</p>
<p>　　于是我又查了查，找到了<a href="https://www.cnblogs.com/Nonono-nw/p/3462183.html" target="_blank" rel="noopener">答案</a> 。这篇博文里，我以往看到的vector初始化方式都是“一、vector 的初始化”写到的五种方式，这五种方式都需要在初始化的时候规定vector的大小。但是这次我在这篇博文“三、顺序访问vector的几种方式”看到了<code>vector&lt;int&gt; a;</code> 这样的形式，这就证明了我的猜想是正确的。其实后来又看了看其他人写的关于vector的博文，大多在最开始就写了<code>vector&lt;int&gt; a;</code> 这种初始化方式，只能说我一开始学vector的时候太懒了，没多看几篇文章，弄得我在用vector的时候还得去”猜“vector的某种用法(好蠢)。</p>
<p>　　还有就是由于第一次接触到二维vector的用法，不太熟悉导致编译错误耽误了一段时间。本来应该是这样对二维vector插值的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; group;</span><br><span class="line">group.push_back(strs[i]);</span><br><span class="line">ans.push_back(group);</span><br><span class="line"><span class="comment">//注意vector里push_back和insert用法上的区别，不要记混了</span></span><br></pre></td></tr></table></figure>
<p>我硬是自作聪明，施展了一番奇技淫巧：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ans.push_back(group.push_back(strs[i]));</span><br></pre></td></tr></table></figure>
<p>看起来挺厉害的，结果就是<strong>一直报错还搜不到报错的原因</strong>，幸好后来脑子转过弯了，改了代码后提交了一次就Accept了。顺便一提，提交之后发现这是我通过的第一道medium题。</p>
<p>　　看了看官方题解，我的解法就是解法一的思路。解法二的思路我记得脑海中曾经闪过，但是感觉有点麻烦就放弃了，不过解法二的时间复杂度比解法一小。然后最让我感到震惊的是该题<a href="https://leetcode-cn.com/problems/group-anagrams/comments/38143" target="_blank" rel="noopener">评论区第一条</a>：</p>
<blockquote>
<p>在美版leetcode上看到大神的思路，用质数表示26个字母，把字符串的各个字母相乘，这样可保证字母异位词的乘积必定是相等的。其余步骤就是用map存储，和别人的一致了。</p>
</blockquote>
<p>这其实跟我最开始的思路“字母转化为数字然后相加”很相似，但是他用质数相乘解决了我思路中“12+14=13+13“这样的问题。只不过质数相乘的做法可能会溢出，python不会溢出，因为python的int是无限大的。</p>
<p><strong>收获：</strong> </p>
<ul>
<li>了解到vector初始化可以不规定大小</li>
<li>学会了二维vector插入元素的正确</li>
<li>复习了map的初始化、获取长度、插入元素</li>
</ul>
<hr>
<p>2020.04.07</p>
<p><a href="https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/528/week-1/3289/" target="_blank" rel="noopener">Counting Elements</a> 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong></p>
<p>　　不知道题目意义何在，只要知道map以及map.find()怎么用，半分钟不到就能解决。而且题目下面还给了提示说用Hash，感觉就像是一个map教学题。提交成功后才发现这道题根本就不在题库里，可能是太过于简单了吧，不知道把它出在这个30天挑战里干嘛。</p>
<p><strong>收获：</strong> 无</p>
<hr>
<p>2020.04.08</p>
<p>876-Middle of the Linked List    题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong></p>
<p>　　第一次做链表题目，很久都没接触过链表了，所以懵了一会儿。题目不难，很快就做出来了。因为答案要返回中间节点到末尾的子链表，所以找到中间节点时候我还在想要不要重新创建一个相同大小的链表然后一一赋值呢？突然我灵机一动，直接创建一个指针去指向中间节点不就好了嘛！<code>ListNode *ans=middle;</code><br>　　提交后看评论区，终于见识到了耳闻已久的“快慢指针”在此题中的应用。</p>
<p><strong>收获：</strong> </p>
<ul>
<li>复习了链表的相关操作，如链表的遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(ListNode* temp=head; temp-&gt;next!=<span class="literal">NULL</span>; temp=temp-&gt;next)&#123;</span><br><span class="line">  listSize++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>学到了“快慢指针”的用法</li>
</ul>
<hr>
<p>2020.04.09</p>
<p>844- Backspace String Compare    题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong></p>
<p>　　题目不难，看到后我立刻就意识到反向遍历是最好的做法，随便想了想就写了第一版，主要思路就是遇到’#’就跳过，代码如下，可是第二个样例都无法通过，因为该思路无法处理多个’#’连在一起的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> newS;</span><br><span class="line"><span class="keyword">int</span> SSize=S.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=SSize<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(S[i]==<span class="string">'#'</span>) i--;</span><br><span class="line">    <span class="keyword">else</span> newS+=S[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我就明白了按照这种思路写，连续的’#’需要用到递归，就类似于多层括号。可是感觉用递归也有点小题大做，突然我就想到了与括号问题紧密联系的一种数据结构——stack，用它可以很好地处理(官方题解一就是用stack进行的)。</p>
<p>　　可是我又感觉用stack还是有点麻烦，灵机一动想了一下，用一个计数器来记录连续的’#’不就好了(跟官方题解二思路一样)，写了一下就提交通过了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> newS;</span><br><span class="line"><span class="keyword">int</span> SSize=S.size();</span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;<span class="comment">//标志着在遍历该符号之前，有几个'#'</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=SSize<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;<span class="comment">//倒序遍历</span></span><br><span class="line">    <span class="keyword">if</span>(S[i]==<span class="string">'#'</span>) flag++;</span><br><span class="line">    <span class="comment">//当前符号为'#'，计数器flag加一</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S[i]!=<span class="string">'#'</span>&amp;&amp;flag==<span class="number">0</span>) newS+=S[i]; </span><br><span class="line">    <span class="comment">//当前符号不为'#'，且之前没有累计的'#'，复制当前符号</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S[i]!=<span class="string">'#'</span>&amp;&amp;flag&gt;<span class="number">0</span>) flag--;</span><br><span class="line">    <span class="comment">//当前符号不为'#'，但是之前仍有累计的'#'未消耗完，跳过当前符号，计数器flag减一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺便一提，在此我的if语句写的有些啰嗦，写这么多的原因是我依稀记得以前在这里踩过坑，对多个条件取反的结果很多时候跟直觉并不一样，比如 $A\ and\ B$  取反是 $\overline A\ or\  \overline B$ , 而并不是直觉上的$\overline A\ and \  \overline B$ ，所以为了避免重蹈覆辙，我宁愿多写一点判断条件。</p>
<p><strong>收获：</strong></p>
<ul>
<li>C++ string 的一些操作，如 str.size(), str.compare()</li>
<li>Mathjax的<a href="https://blog.csdn.net/qq_42659468/article/details/90381985" target="_blank" rel="noopener">一些语法</a>，比如字母上划线，字母之间的空格</li>
<li>虽说我的思路是跟官方题解二相同，但是它的空间复杂度为O(1)，我的还是O($M+N$)，这一点有待学习</li>
</ul>
<hr>
<p>2020.04.10</p>
<p>155-Min Stack 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　第一次写这种“设计对象”的题目。题目很简单，本来想用stack来做，不过后来感觉用stack时不太方便实现getMin()这个函数，所以最终选择了vector，因为在之前浏览vector相关知识的博客中，我记得vector本身就有push_back、pop_back等功能，而且我猜想vector自带getMin( )类似的功能。最后我在<a href="https://www.cnblogs.com/Tang-tangt/p/9352093.html" target="_blank" rel="noopener">这篇博文</a>里找到了该操作，虽然并不是vector自带的，但也很方便。<br>　　中间出现了一个小插曲，就是我对C++里很多内容记得模糊不清了，然后直接把vector创建在构造函数里，导致其他函数无法调用vector。后来我就把构造函数清空，把vector在private里创建就行了。<br>　　不过我提交的代码耗时800+ms，我看别人的代码30+ms就通过了，我估计是<code>*min_element(v.begin(),v.end());</code>这个操作耗费了不少时间。看了一下别的思路，就是在入栈时，同时push实际值、当前最小值，出栈就是同时pop两下。该思路变形就是用两个stack，在入栈的同时，在另一个stack里记录第一个stack当前最小值。也可以用链表来实现，每一个结点里记录了该结点入栈时的最小值。</p>
<p><strong>收获：</strong></p>
<ul>
<li>回顾了C++里面向对象、构造函数等内容</li>
<li>回顾了vector里push_back(x)、pop_back()</li>
<li>学习了vector求最值的操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最大值：<span class="keyword">int</span> maxValue = *max_element(v.begin(),v.end());</span><br><span class="line">最小值：<span class="keyword">int</span> minValue = *min_element(v.begin(),v.end());</span><br></pre></td></tr></table></figure>
<hr>
<p>2020.04.11</p>
<p>543-Diameter of Binary Tree 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　首次写二叉树的题目，题目不难，但我写得磕磕绊绊的，犯了不少错误，耗费了一些时间才提交成功。所以本来以为是个medium的题目，结果还是个easy题(唉太菜了)。<br>　　题目思路并不难，如果曾经学过二叉树的操作，分析几个例子自己模拟一下差不多就能写出来了。我提交后看了看评论区，基本上也都是同样的思路。比如我在写代码的时候，还为自己把常见的的“二叉树深度”概念逆向转换为“二叉树高度”这一思路而自鸣得意，然后发现评论区很多人用词也同样是“高度”……</p>
<p>　　关于代码的错误主要也体现在三点：<br>　　1.因为二叉树左右子节点操作类似，所以我就喜欢复制粘贴代码，然而粘贴后经常忘了改left和right<br>　　2.忘记判断左右子节点是否为空，这一点跑样例的时候控制台会报错，发现了这一点就改正了,在每次进入左右子结点之前判断左右子结点是否为空，然后再进入递归函数<br>　　3.忘记判断根节点是否为空，跑样例的时候没发现，<strong>导致第一次提交Runtime Error了，发现有一组样例输入是空</strong>，这才意识过来问题所在。然后在代码最开始就加上了根节点判别条件，提交就通过了</p>
<p>　　其实本题有一个坑点，只不过题目直接就说出来了 <strong>This path may or may not pass through the root.</strong> 于是在自定义样例的时候，必然要画出一个“最长路径不经过根结点”的二叉树。然后我发现了leetcode居然提供了一个特别实用的功能——<strong>二叉树可视化工具</strong>，就是你在自定义样例的时候，可以实时显示出二叉树的样子。比如，我写了这样一个样例，然后就能即时看到二叉树的样子。<br><code>[1,2,3,4,5,null,null,null,null,6,7,8,9,null,10,11,null,null,null,null,12,13,null,null,14,15,null,null,16]</code><br><img src="http://m.qpic.cn/psc?/V138MMQ83qT5pq/h4SLI6MeeCc7mRdKk01uskDCE8*0CvhXv4YbFx6rpz0V6rKS16mCxdoOmVbmT3hnsVTRm.nzjIpniRz.fJ8Z2c71F41daQSLOi3OJhbIxF8!/b&amp;bo=5gEdAuYBHQIRGS4!&amp;rf=viewer_4&amp;t=5" alt=""></p>
<p>　　在提交后看了看别人的代码，发现其他人写的都很简短，差不多行数是我的一半。对比了一下，发现是因为在遍历二叉树的同时，需要返回两个值，这在python可以实现但C++/Java不行，所以很多人选择定义了一个全局变量Max来记录，我本来也该设置个全局变量的，不知道为什么脑子抽了写了另外一个函数再遍历一次。所以别人一个函数，我两个函数，行数自然就多了一倍。而且我发现我的一些代码写得很啰嗦，比如我会在每次进入左右节点之前都进行判空：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Node-&gt;left!=<span class="literal">NULL</span>) leftMax=findMax(Node-&gt;left, nowMax);</span><br><span class="line"><span class="keyword">if</span>(Node-&gt;right!=<span class="literal">NULL</span>) rightMax=findMax(Node-&gt;right, nowMax);</span><br></pre></td></tr></table></figure></p>
<p>而实际上，只需要在进入递归函数后的第一行，写下一句<code>if(Node==NULL) return 0;</code>就行了，简洁高效。</p>
<p><strong>收获：</strong></p>
<ul>
<li>二叉树的相关操作</li>
<li>leetcode二叉树可视化</li>
<li>以后再补交一份简洁版的代码</li>
</ul>
<hr>
<p>2020.04.12</p>
<p>1046-Last Stone Weight 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　题目挺简单的，没什么好说的，提示说可以用heap去做本题，我懒得看，就直接用vector+sort写了。提交了之后看了看评论区，看到别人的代码里用到了C++ STL里的priority_queue，这个STL我好像很少用过，查了查，原来优先队列就是用堆实现的。就顺便学习了一下堆的相关操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化优先队列</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; q;<span class="comment">//降序</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; q;<span class="comment">//升序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插值，自动排序</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; vec.size() ; i ++)&#123;</span><br><span class="line">  q.push(stones[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">q.size();<span class="comment">//获取大小</span></span><br><span class="line">q.top();<span class="comment">//获取顶端元素</span></span><br><span class="line">q.pop();<span class="comment">//弹出顶端元素</span></span><br><span class="line">q.empty()<span class="comment">//是否为空</span></span><br></pre></td></tr></table></figure>
<p><strong>收获：</strong></p>
<ul>
<li>学习了用 C++ STL 里的 priority_queue 来进行 heap 的相关操作</li>
</ul>
<hr>
<p>2020.04.13</p>
<p>525-Contiguous Array 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　<strong>非常沮丧，第一次做LeetCode没写出来……(不过我也知道这种情况在今后会出现更多次)</strong> 首先，看到本题就应该很轻易地就知晓暴力$O(n^2)$肯定是会超时的。之后看到“求最值”，想到在<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie" target="_blank" rel="noopener">算法小抄</a>上看到的 <strong>“动态规划问题的一般形式就是求最值”</strong> 就以为是dp，想了好久没写出来dp的推导式，遂放弃dp。然后随便想了个算法，写完后自制几个样例测试，结果输出不对。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>尝试过分治，也不行，还想过把第一个样例转化为 [3,2,8,3,2] 这样的形式再进行操作，也不行。然后硬着头皮想了了五六个小时依旧无果，撑不住了，去看了<a href="https://leetcode-cn.com/problems/contiguous-array/solution/lian-xu-shu-zu-by-leetcode/" target="_blank" rel="noopener">官方题解</a>。题解的思路确实巧妙，或许之前的五六个小时里向题解的思路靠近过，但始终还是没能触碰到，不愧是medium题。<br>　　看了题解后，按照题解的思路去写了一遍代码，跑了一些样例通过了，结果 [0,1,0,1,0,1,0,1] 的输出还是错的(幸好能通过该样例及时发现问题，不然又要耽误好多时间)。想了一会儿没明白，只能跑去看题解的代码，发现原来是我少写了一句<code>mAp[0]=-1;</code>。因为<a href="https://leetcode-cn.com/problems/contiguous-array/solution/lian-xu-shu-zu-by-leetcode/" target="_blank" rel="noopener">题解</a>所画的那个折线图，起始于坐标0，第一个数据的坐标是1。然而在代码里，第一个数据的下标是0,丢失了原来的坐标0，所以就需要额外在map里插入一个坐标-1 (题解三里Java代码写的是<code>map.put(0, -1);</code>)。<del>看了题解思路还写不出来正确代码实属大菜逼</del><br>　不得不再次对此题进行一下感叹，该题<strong>并没用到任何常见或高深的“算法”</strong>(评论区也没看到有人用其他什么算法)，也与数学无关，仅仅是靠思维上的一个技巧来进行解题,真可谓是“大智若愚，大巧若拙”。</p>
<p><strong>收获：</strong></p>
<ul>
<li>学会了面对失败，面对挫折，<strong>在LeetCode我是来刷题的，而不是来发明算法的</strong>，想不出来解法很正常，以后如果思路停滞超过半小时，就直接看题解进行学习，不能再闭门造车浪费时间</li>
<li>看了看别人的代码，学到了map的一些简洁操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我之前是这样写的，直接插入，然后判断插入是否成功</span></span><br><span class="line">pair&lt;<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; insertPair;</span><br><span class="line">insertPair=m.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(count,i)); <span class="comment">//插入</span></span><br><span class="line"><span class="keyword">if</span>(insertPair.second==<span class="literal">false</span>)&#123; <span class="comment">//如果插入失败</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//别人的写法，先查找，然后再插入</span></span><br><span class="line"><span class="keyword">auto</span> iter = m.find(count);</span><br><span class="line"><span class="keyword">if</span>(iter == m.end())&#123;<span class="comment">//如果没找到</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(iter != m.end())&#123;<span class="comment">//如果找到了</span></span><br><span class="line">  m.insert(&#123;coutn,i&#125;);<span class="comment">//插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2020.04.14</p>
<p><a href="https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/529/week-2/3299/" target="_blank" rel="noopener">Perform String Shifts</a> 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　类似于2020.04.07的题，本题又是一道不在题库中的题，题目很简单，而且稍微需要思考的点已经给出了提示，就没什么好说的。很惭愧，我一开始看数据范围很小，就打算直接暴力模拟。然后看到了提示2，我才知道“左右抵消”这种操作。<br>　　第一次提交的结果是Runtime Error，很明显超数组下标了，看了看代码才意识过来，和当年做的“约瑟夫环”类似，这种首位衔接循环的情况，当位移的长度大于数组长度，必须不断减小到数组长度之内<code>while(count&gt;sSize) count-=sSize;</code></p>
<p><strong>收获：</strong></p>
<ul>
<li>看了别人的代码，才想起来减小位移长度时并不需要用循环，直接取模就好了<code>if(count&gt;sSize) count=count%sSize</code></li>
</ul>
<hr>
<p>2020.04.15</p>
<p>238-Product of Array Except Self 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　第二次看到题目后不会做……我知道这一天肯定会再次到来，但是我没想到这个“再次”来得这么快(<del>看来我还是高估了自己的智商</del>)……<br>　　题目看上去很简单，但是加了限制条件后就变得很困难。抛开限制，本题貌似最简单的做法就是所有数字相乘，然后每次除以某个数字，不过官方题解说该做法当遇到某数为0时就会出错，因为不能除以0(我还没想到这一点)。或者是对于每个数，每次都从头到尾跳过该数字乘一遍，当然这种做法时间复杂度是$O(n^2)$,不满足$O(n)$的要求。<br>　　苦于“除法”的思维定式，找不到答案，只能看题解。题解的思路概括起来就是简单一句话<code>乘积 = 当前数左边的乘积 * 当前数右边的乘积</code>,不得不赞叹巧妙。本题同样没用到什么高明的算法，评论区称之为“脑筋急转弯”。<br>　　本题的进阶解法更为精简，但是进阶要求的描述<code>出于对空间复杂度分析的目的，输出数组不被视为额外空间</code>我并不是很满意，我以为“输出数组不被视为额外空间”的意思是直接把输出数组忽视掉，谁知道题解反而是去占据了“输出空间”去解题，让该进阶解法有种利用漏洞“捡漏”的感觉。我觉得，进阶描述应该更准确地说 <strong>“除了输入数组、输出数组以外，不能够定义任何新的数组”</strong>。</p>
<p><strong>收获：</strong></p>
<ul>
<li>再次明白了自己智商有待充值</li>
</ul>
<hr>
<p>2020.04.16</p>
<p>678-Valid Parenthesis String 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　<strong>本题是我从开始刷LeetCode到目前为止做得最崩溃的一道题……</strong>刚看到此题，我就有种扑面而来的熟悉感——这不就是我19年参加北京理工夏令营的机试第一题吗？</p>
<p><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/comments/72887" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parenthesis-string/comments/72887</a></p>
<p>stack.top()</p>
<p><strong>收获：</strong></p>
<ul>
<li>再次明白了自己智商有待充值</li>
</ul>
<hr>
<p>2020.04.17</p>
<p>200-Number of Islands 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　题目太过于经典没什么好说的，《挑战程序设计竞赛》第32页原题，大一的时候就做过，算是我对于 <strong>深度优先搜索(dfs)</strong> 这个知识点的启蒙题之一吧。<br>　　开始编写代码，我习惯性地设置了一个二维数组flag进行标记，虽然后来flag发现并没有用就删掉了，但是在这个过程中我学到了如何对一个空二维vector初始化行列数。<br>　　提交成功之前，代码有三处错误：<br>　　1.第一次跑样例 Runtime Error，应该是数组越界，看了一下，是因为没有判断nextI和nextJ的范围，补上了一句<code>if(nextI&gt;0&amp;&amp;nextI&lt;rows&amp;&amp;nextJ&gt;0&amp;&amp;nextJ&lt;columns)</code><br>　　2.第二次跑样例发现结果不对，插入了几个printf查错，最后发现是判断范围的语句里，nextI&gt;=0 nextJ&gt;0 都少写了一个 = 号，低级错误<br>　　3.提交后又报错Runtime Error，发现跟2020.04.11二叉树错因一样:<strong>某个样例输入为空</strong><code>[]</code>……二叉树你输入空就算了，这个题还输入个空vector，无语…… 然后在求输入二维vector行数后加了个判断，如果rows=0就直接返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rows=grid.size();</span><br><span class="line"><span class="keyword">if</span>(rows==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">columns=grid[<span class="number">0</span>].size();</span><br></pre></td></tr></table></figure>
<p>　　今天还有一个奇怪的现象就是，在提交成功后，我点击题目，跳转回了30-Day LeetCoding Challenge的做题页面，而不是题库。我以为本题跟2020.04.07、2020.04.14两题类似，没有被收入进题库。但是我感觉按常理来讲，本题难度远高于之前的两题，应该是medium难度的。于是我复制题目名称在题库里搜索，果然搜到了一道medium题，证实了我的猜想。不过，我又在题库里搜了之前的两道题，依旧没有被收录。</p>
<p><strong>收获：</strong></p>
<ul>
<li>二维vector求行列数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rows=grid.size();</span><br><span class="line">columns=grid[<span class="number">0</span>].size();</span><br></pre></td></tr></table></figure>
<ul>
<li>二维vector初始化行列数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; flag;</span><br><span class="line">flag.resize(rows);<span class="comment">//flag有rows行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; i++) flag[i].resize(columns);<span class="comment">//每一行有columns列</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>输入的二维vector记得要进行判空</strong></li>
</ul>
<hr>
<p>2020.04.18</p>
<p>64-Minimum Path 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　初看题目，想着要用<strong>深搜</strong>或者<strong>广搜</strong>，但是感觉这样做有点麻烦，而且很可能会超时。然后我灵光一闪，发现这道题和以前做过的一道初级dp基本上一致。于是顺着思路就开始写代码，测试样例的时候虽然结果正确，但是突然发现，按照往常习惯设置的二维dp数组根本没什么用。因为grid每个元素的值用过之后就不用再记录了，取代掉也没有问题，所以完全可以直接就在grid里进行操作，不用再额外设置数组。删除修改了一些代码，提交一遍过了。<br>　　提交之后我就想找以前在哪里见过这道题，《挑战程序设计竞赛》没有，《ACM book》没有，《<a href="https://labuladong.gitbook.io/algo/" target="_blank" rel="noopener">labuladong的算法小抄</a>》也没有。想了一会儿，突然想起一个网站，打开该网站，果然找到了—— <a href="https://www.icourse163.org/learn/PKU-1001894005?tid=1001994002#/learn/content" target="_blank" rel="noopener">中国大学MOOC 程序设计与算法（二）算法基础 郭炜</a> 第五周第一题“数字三角形”。<br>　　除此之外，我今天又发现了跟昨天一样的奇怪现象——在提交成功后，我点击题目，跳转回了30-Day LeetCoding Challenge的做题页面，而不是题库，之后也在题库搜到了该题。根据我的观察，我感觉是因为昨天、今天这两道题的官方题解是被锁住的，可能是因为这个原因才没有直接跳转到题库里。顺便我发现这两道题在LeetCode-CN的官方题解居然是开放的…惊了，<strong>第一次发现中国版比国外原版良心的应用程序</strong>。</p>
<p><strong>收获：</strong> 无</p>
<hr>
<p>2020.04.19</p>
<p>33-Search in Rotated Sorted Array 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　今天感觉还不错，这道没见过的medium题由自己想出来了。这道题本身不难，直接做就是$O(n)$，但是题目附加了时间复杂度为$O(log\ n)$,难度就随着而升了。但是这个给出的时间复杂度限制同时也给了我们一个提示——本题很可能和二分查找相关。然而本题的输入数组是一个rotated有序数组。rotate直译为旋转、转动，我认为当算法题的数组rotated，意思就是这是个首位相连的循环数组。二分查找的适用范围是整体有序的数组，所以就不能直接套用。<br>　　我最开始想，<strong>先用排序算法排序，然后再二分查找</strong>。但是经过研究，我发现<strong>最快的排序算法的复杂度也高达$O(nlog\ n)$</strong>，所以这个想法就只能舍去了。然后我想了一会儿没什么思路，本来准备按照之前的自我约定“不会就直接看题解不要浪费时间”，但是我总有一种“我能做出来”的感觉，又思考了一会儿，竟然真的想出来了。</p>
<blockquote>
<p>因为输入的数组并不是完全乱序的，而是部分有序的，所以可以先用二分查找找出最小值，这样就能计算出数组的偏移量，然后计算出元素本来的坐标，就可以再次利用二分查找解题了。<br><strong>注意本算法的第一步</strong>：为什么数组是乱序的时候，还可以利用二分查找找到最小值？<br>——因为数组不是完全乱序而是部分有序的，所以最小值左边所有的数字，都会大于最小值右侧的所有数字，因此就可以使用二分查找。</p>
</blockquote>
<p>　　不过写代码的过程并不是很顺利。因为我之前虽然接触过二分查找，但是没有深入地学习过。并且虽然我知道二分查找的写法有很多种，然而我没想到《挑战程序设计竞赛》139页、《ACM Book》59页、《<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/er-fen-cha-zhao-xiang-jie" target="_blank" rel="noopener">labuladong的算法小抄</a>》<strong>三处的代码都各有不同</strong>……本来我就不怎么会二分查找，还碰到这种情况，就只能迷迷糊糊地瞎写代码了……所以虽然代码整体有两次二分查找，但是第一处二分查找最小值用的是《挑战程序设计竞赛》139页的写法，第二处二分查找用的是《<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/er-fen-cha-zhao-xiang-jie" target="_blank" rel="noopener">labuladong的算法小抄</a>》的写法。这样迷迷糊糊地写肯定要出错，然后<strong>中间就写了一堆cout查错，再慢慢修补</strong>。共写了两版代码。第一版的代码题目样例过了，但是没过我自己出的一个样例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">4</span> <span class="comment">//题目样例</span></span><br><span class="line">nums = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>], target = <span class="number">5</span> <span class="comment">//自己出的样例</span></span><br></pre></td></tr></table></figure>
<p>　　然后改了改，第二版代码提交出错，败在了<code>nums= [1,3] target=1</code>。这个样例就是说数组没有偏移，或者是偏移后恰好归原位。把这个样例放在代码里测试，根据中间cout输出的结果，发现是第一个二分查找出错了。于是在第一个二分查找前加了个if判断句，判断数组是否本来就是顺序的 <code>if(nums[0]&lt;nums[right]) move=0;</code>，提交通过。<br>　　提交后，我第三次发现跟前两天一样的现象——交成功后，我点击题目，跳转回了30-Day LeetCoding Challenge的做题页面，而不是题库，之后也在题库搜到了该题。该题的题解同样也是锁着的，就证实了我昨天的猜想：因为英文版题解是锁着的，所以没有直接跳转到题库。同样地，该题中文版题解是开放的。<br>　　然后逛了逛英文题解区，发现<a href="https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14425/Concise-O(log-N" target="_blank" rel="noopener">最高得票题解</a>-Binary-search-solution)的代码基本上与我的代码一致，就是用两次二分查找，先找最小值，再进行第二次二分查找。中文题解区的<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/duo-si-lu-wan-quan-gong-lue-bi-xu-miao-dong-by-swe/" target="_blank" rel="noopener">这篇文章</a>的思路一，也基本上跟我一模一样。后来在评论区貌似看到了更精简的解法 <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/ji-jian-solution-by-lukelee/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/ji-jian-solution-by-lukelee/</a> ，暂时没仔细看，以后再补。</p>
<p><strong>收获：</strong> </p>
<ul>
<li>第一次在LeetCode上遇到二分查找的题目</li>
<li>之后要重新学透二分查找</li>
</ul>
<hr>
<p>2020.04.20</p>
<p>1008-Construct Binary Search Tree from Preorder Traversal 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　题目就是给一个先序遍历序列，以此建立二叉搜索树。起初，以为是个模板题，就去找二叉搜索树的相关资料。但是之后又感觉不是模板题，因为二叉搜索树插入元素的模板代码是递归，而题目注明了先序遍历序列不大于100，由此我就想到2020.04.16数据长度也是不大于100，但是用递归求解会翻车。<br>　　因为二叉搜索树的插入元素递归模板并不要求输入序列的内部顺序，而本题给的输入序列是先序遍历序列，于是我想先序遍历序列+二叉搜索树这两者的特性结合可能会引导出此题的非递归解法。我想了一会儿有点思路，但是感觉有点麻烦，就一不做二不休直接套<a href="https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/er-cha-sou-suo-shu-cao-zuo-ji-jin" target="_blank" rel="noopener">二叉搜索树插入元素模板</a>,交上去居然一遍过了，我以为会很慢，但显示是0ms……所以整个过程就是 <strong>我以为是模板题 -&gt; 我以为不是模板题 -&gt; 结果还是模板题</strong>……<br>　　令我感到惊讶的是，提交后看评论区、官方题解，有递归、非递归、分治等思路，但是几乎大部分代码与我的思路都不一样，只有零星几个与我代码结构相近的评论<br><a href="https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/comments/76567" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/comments/76567</a><br><a href="https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/comments/41731" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/comments/41731</a><br>观察学习了一会儿，发现了区别在于别人更多的是在考虑如何利用所给出的<strong>先序遍历序列</strong>去构建一个<strong>二叉树</strong>，其中再附加一些额外的细节使得构建的是二叉搜索树（其实就是在我之前的思考过程中嫌麻烦被放弃掉的思路）；而我的做法是如何利用<strong>一个个的元素</strong>直接构建一个<strong>二叉搜索树</strong>。可以说我的做法有“取巧”的嫌疑，因为我这种思路虽然结果正确，但并不在意输入序列的结构，这样<strong>会使得题干中“先序序列”这一要点被绕过、被忽略掉</strong>，或许就违背了出题者的初衷。</p>
<p><strong>收获：</strong></p>
<ul>
<li>懒癌发作，其他解法之后找时间再补</li>
<li>学会了二叉搜索树如何插入元素，不过并不熟练</li>
<li>知道了C++ new 返回的是指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> MyClass 返回的是MyClass的指针。 </span><br><span class="line">创建成功将地址回以MyClass *的形式返回，创建失败则返回<span class="literal">NULL</span>。</span><br></pre></td></tr></table></figure>
<ul>
<li>确认了我之前一直未核实的一个猜测：<strong>C++类里面的函数和变量是不分先后顺序的</strong>，他们是平级的，这点和不使用类直接定义全局函数或者变量不同。</li>
</ul>
<hr>
<p>2020.04.21</p>
<p><a href="https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/530/week-3/3306/" target="_blank" rel="noopener">Leftmost Column with at Least a One</a> 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　今天的题目虽然做出来了，不过说实话如果只凭我自己想，估计一时半会儿写不出来。题目的难点在于最多只能查询矩阵元素1000次，而矩阵长宽各不大于100也就是元素最多有10000个。<br>　　最终做出来还是靠题目下方给的两个提示，第一个提示说用二分查找做；第二个提示应该算是此题的一个特殊思路，可以说是一个奇技淫巧而不是某类算法。最终我选择用二分查找去做，因为很显然二分查找的适用面更广，有利于我今后刷题。<br>　　首先思考为什么会提示用二分查找——因为本题矩阵的每一行的元素都是非递减的，也就是说<strong>已经排好顺序</strong>的，而二分查找恰恰与<strong>已排序序列</strong>有着紧密的联系(未排序序列可以先排序)。本题二分查找的思路就是对每一行进行二分查找然后更新答案。同时粗略计算一下，最多100行100列，那么查询矩阵元素的次数就大概是$(log_2\ 100)*100 \approx664.4$，小于题目限制的1000次。<br>　　本题写代码所使用的二分查找，是除了常用的“精确查找某一个数”之外的另一个应用方式——<strong>查找左/右边界</strong>。至于什么叫“查找边界”，可以看如下两篇文章。<br><a href="https://blog.csdn.net/weixin_43784989/article/details/98229031" target="_blank" rel="noopener">二分查找——不但可具体位置，也可查左边界或右边界</a><br><a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/er-fen-cha-zhao-xiang-jie" target="_blank" rel="noopener">二分查找详解</a><br>　　之后，我照着<a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/er-fen-cha-zhao-xiang-jie" target="_blank" rel="noopener">二分查找详解</a>的模板完成了本题。不过第一次提交却报错了，说是查询矩阵元素次数大于1000次。当时就很纳闷，按照计算不应该会这样啊？再仔细一看代码，原来抄模板的时候过于死板，所以导致了二分查找模块里多了两次重复查询。修改之后就顺利通过了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改前</span></span><br><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(binaryMatrix.get(nowRows, mid)==target) right=mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(binaryMatrix.get(nowRows, mid)&lt;target) left=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(binaryMatrix.get(nowRows, mid)&gt;target) right=mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> midElement=binaryMatrix.get(nowRows, mid);</span><br><span class="line">    <span class="keyword">if</span>(midElement==target) right=mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(midElement&lt;target) left=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(midElement&gt;target) right=mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　本题是新题未曾收纳入题库。我看出来了，在这“30天挑战”里，有hint的题目很可能就是新题，比如2020.04.07的题目。由此我也发现了，LeetCode中文版虽然很多官方题解不需要会员就能查看，但是英文版这边貌似更容易出新题。</p>
<p><strong>收获：</strong></p>
<ul>
<li>学到了二分查找左/右边界，不过并不熟练</li>
<li>知道了Mathjax的约等于号<code>\approx</code></li>
</ul>
<hr>
<p>2020.04.22</p>
<p>560-Subarray Sum Equals K 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　题目所给的输入数组长度不超过20000，暴力$O(n^2)$肯定是不行的。然后我想到了动态规划sum(i,j)这种形式，可是sum数组大小为$20000<em>20000=4</em>10^8$估计要爆内存，而且填充二维dp数组的过程也是$O(n^2)$，遂放弃。然后我想起了之前做过的 2020.04.13 <strong>525-Contiguous Array</strong> 与本题有点类似，想从中获取灵感，然而照葫芦画瓢构思了一会儿还是没写出来……然后就去看题解了。<br>　　看了官方题解，方法一的时间复杂度居然是$O(n^3)$，暴力程度超出了我的想象力，让我发出“原来还能这么暴力啊?”这样的惊叹……(这种暴力解法看多了印在脑海里真的会降智商的)<br>　　官方题解方法二、三都是$O(n^2)$，我最初构思的暴力解法就跟方法三类似，但是我惊讶于这么大的时间复杂度题解上说居然能通过……？印象中$4*10^8$一般都会超时吧？<a href="https://zhidao.baidu.com/question/489302245.html" target="_blank" rel="noopener">查了一下</a>也确实如我所想，可见本题所测试的数据有点弱。看了看官方题解下面的评论区，有人说python前三种解法都会超时，果然印证了我的疑惑。<br>　　然后开始看官方题解方法四，思路以及代码结构与<strong>525-Contiguous Array</strong>确实十分相似( 尤其是那个再次出现在题解Java代码里的map.put(0, 1) ) ，可惜我往这个方向思考过，但就是没想出来本题的具体的细节(主要受<strong>525-Contiguous Array</strong>官方题解里的那个折线图影响，我做本题的时候一直想画出类似的折线图辅助解题，一直没画出来，导致我放弃思考……而本题的官方题解里也没画出折线图，很可能说明本题确实画不出来折线图来描绘解题思路)。我观察对比了这两道题，发现两题的评论区经常会出现一个我之前未曾接触过的词汇“前缀和”，看来的确是一类问题，其最优解法就是使用HashMap。<br>　　前两次提交代码均为 Wrong Answer，两次都是<code>[1] 0</code>这一组样例过不去。找了一下原因发现是<code>查找sum[i]-k是否曾经出现过</code>、<code>更新map[sum[i]]</code> 这两个模块位置我写反了，其他样例基本上看不出来这个问题，但是当k=0时就会立刻把这个错误暴露出来。<br>　　幸亏LeetCode能返回错误样例，否则像以前做ACM题那样，不知道又要花费多少时间debug(而且很可能照着别人的代码修改后还不知道为什么要这么改)。虽然以前感叹过很多次，不得不再次感叹：<strong>做算法题太容易忽略掉这种细枝末节的地方，导致结果出错</strong>，然后花费大量时间debug。</p>
<p><strong>收获：</strong></p>
<ul>
<li>了解到“前缀和”这一词汇</li>
<li>浏览英文版LeetCode评论区他人的代码，发现了一些我不曾了解的map的特性，由此可以简化代码中map的相关操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的代码</span></span><br><span class="line"><span class="keyword">auto</span> iter = mp.find(sum-k);</span><br><span class="line"><span class="keyword">if</span>(iter!=mp.end())</span><br><span class="line">  ans+=mp[sum-k];</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = mp.find(sum);</span><br><span class="line"><span class="keyword">if</span>(it!=mp.end())</span><br><span class="line">  mp[sum]++;</span><br><span class="line"><span class="keyword">else</span> mp[sum]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//别人的代码</span></span><br><span class="line"><span class="keyword">if</span> (mp[sum-k]) </span><br><span class="line">  ans += mp[sum-k];</span><br><span class="line"></span><br><span class="line">mp[sum]++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">两种代码的差异可以用以下三个map的特性来解释：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 下标访问会有一个返回值</span></span><br><span class="line"><span class="comment">https://blog.csdn.net/qq_40056908/article/details/83538290  </span></span><br><span class="line"><span class="comment">这篇博文中，下标访问输出了一个本来没有的m[4]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 在map中使用下标[]访问不存在的元素将导致在map容器中添加一个新的元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. map元素具有默认值</span></span><br><span class="line"><span class="comment">https://www.cnblogs.com/musecho/p/11996287.html</span></span><br><span class="line"><span class="comment">当map内元素值为int类型或常量时，默认值为0。</span></span><br><span class="line"><span class="comment">当为String类型时，默认值不明，不显示。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>另外，在<a href="https://leetcode.com/problems/subarray-sum-equals-k/discuss/378788/C++-solution-explained-with-an-example-..." target="_blank" rel="noopener">这篇题解</a>的评论区有人提出如下观点，意思就是<strong>上一条提及的那种简短代码风格有弊端</strong>。具体的弊端在<a href="https://blog.csdn.net/qq_40056908/article/details/83538290" target="_blank" rel="noopener">这篇博文</a>中也有阐述 <strong>“这种下标访问模式有一个缺点就是如果被访问元素不在map中，会插入此元素并初始化”</strong></li>
</ul>
<blockquote>
<p>I think the part if (m[s - k]) could be improved. If s-k is not in the map, after this if-check, you are implicitly inserting m[s-k] = 0 in your hash map. Therefore the size of the hash map is a little larger than its optimal size (However still O(N)). I would replace it with something like this:<br>auto it = m.find(s-k);<br>if (it != m.end()) r += it-&gt;second;</p>
</blockquote>
<ul>
<li>在<a href="https://leetcode.com/problems/subarray-sum-equals-k/discuss/591787/C%2B%2B-Simple-Solution-and-Explanation" target="_blank" rel="noopener">该题解</a>下方评论区，我看到了有人说“<strong>use unordered_map it will take less time</strong>”，我想起来map是会默认排序的，所以不需要这个特性的时候，可以用unordered_map来加快代码运行速度。我特意还去百度搜了一下两种map的区别 <a href="https://blog.csdn.net/haoliliang88/article/details/92394005" target="_blank" rel="noopener">map/unordered_map原理和使用整理</a></li>
</ul>
<blockquote>
<p>运行效率方面：unordered_map最高，而map效率较低但 提供了稳定效率和有序的序列。<br>占用内存方面：map内存占用略低，unordered_map内存占用略高,而且是线性成比例的<br>需要无序容器，快速查找删除，不担心略高的内存时用unordered_map；有序容器稳定查找删除效率，内存很在意时候用map。</p>
</blockquote>
<hr>
<p>2020.04.23</p>
<blockquote>
<p>你们初刷leetcode时会怀疑自己的智商么？ - 李欣宜的回答 - 知乎<br><a href="https://www.zhihu.com/question/388971497/answer/1164383895" target="_blank" rel="noopener">https://www.zhihu.com/question/388971497/answer/1164383895</a><br>刷 LeetCode 吃力正常吗？ - 微调的回答 - 知乎<br><a href="https://www.zhihu.com/question/31092580/answer/1171079380" target="_blank" rel="noopener">https://www.zhihu.com/question/31092580/answer/1171079380</a></p>
</blockquote>
<p>今天看了这两个回答，再次点醒我：</p>
<ol>
<li>见题秒题并不是常态</li>
<li>遇到不会做的题才是正常的</li>
<li>既然大部分人刷个LeetCode的都感到不适，那么我们也并<strong>不用去羡慕、神化</strong>那些OIer、ACMer在LeetCode所向披靡，因为他们背后也曾经付出过太多的汗水才能取得今天轻松切题的姿态</li>
</ol>
<p><br></p>
<p>201-Bitwise AND of Numbers RangeBitwise AND of Numbers Range 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　仅看题目描述会觉得挺简单的，但是当看到数据范围 <code>0 &lt;= m &lt;= n &lt;= 2147483647</code>就会意识到这道题并不好做。$2147483647=2^{31}-1$即为32位int的最大值。21亿的数据量，很明显即使是最直接的 $O(n)$ 代码也会超时。想了一会儿，想不出来其他的做法，索性就写了个 $O(n)$ 代码交上去了，果不其然Time Limit Exceeded。然后又去打表找规律，貌似想出来了，写了写，过了几个样例，结果交了两次都是Wrong Answer，说明我的思路考虑不周全，并不具有普适性。<br>　　没办法，就只能去看题解了。代码非常非常短，但是得出代码的思考过程却并不简单。如下两篇题解思路一致，二者结合多看几遍，大概就能理解其中的含义了。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/solution/0he-shui-yu-du-shi-0-by-powcai/198786" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/solution/0he-shui-yu-du-shi-0-by-powcai/198786</a><br><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/solution/yi-wei-suan-fa-by-tuotuoli/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/solution/yi-wei-suan-fa-by-tuotuoli/</a></p>
</blockquote>
<p><strong>收获：</strong></p>
<ul>
<li>了解到Mathjax里指数大于1位数时要用{}括起来，比如<code>$2^{31}$</code></li>
<li>了解到<a href="https://www.zhihu.com/question/20134106/answer/312304677" target="_blank" rel="noopener">Markdown如何插入空行</a></li>
</ul>
<hr>
<p>2020.04.24</p>
<p>146-LRU Cache 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　题意并不难理解，LRU的概念也在学操作系统的时候学过。本题的难点在于进阶要求两个操作时间复杂度均为$O(1)$. 我思考了一会儿，想到了几个可以在本题应用的数据结构：hashmap、vector、双向链表。<strong>map查询和删除操作$O(log\ n)$，但是map不能自定义排列顺序；vector可以自定义排列顺序，查询操作$O(1)$，但是vector的删除操作$O(n)$</strong>(因为删除完元素要对整个数组进行移动)；<strong>双向链表可以自定义排列顺序，删除操作为$O(1)$，但是查询操作$O(n)$</strong>(因为不知道要找的元素在哪只能顺着结点一个个找)。<br>　　这就让我很犯难，想了一会儿只能写了个$O(n)$代码交差了。用map+vector进行实现，map主要用来判断进程是否出现过，vector则按照进程使用情况对它们排序。删除操作使用了新学的vector.erase(key) 和 map.erase(key). <strong>事实证明这样做确实很慢，我的代码640ms，而大部分人的代码在200ms以内</strong>。<br>　　提交后看题解，发现题解基本上用的是<strong>hashmap+双向链表</strong>实现$O(1)$的。那么为什么之前我已经想到了这两种数据结构，但是最后却没能成功应用呢？因为<strong>我最初的设计是 map存储{key,value}、双向链表存储key</strong>。而<a href="https://leetcode-cn.com/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/" target="_blank" rel="noopener">题解</a>设计的结构是 <strong>map存储{key, Linklist_Node_Address}</strong>，那么原本在map里的value存储在哪里呢，<strong>{key, value}一起存储在双向链表的结点里</strong>了(结点存储的信息不止一个哦)。这样一来hashmap和双向链表就紧密联系起来，形成了一个新的数据结构：<strong>哈希链表</strong>。<strong>哈希链表</strong>就巧妙地结合了二者的优点，使得查询和删除的时间复杂度都能为O(1)。</p>
<p><strong>题外话：</strong><br>　　本题<a href="https://leetcode-cn.com/problems/lru-cache/comments/110611" target="_blank" rel="noopener">评论区第一条</a>说“<strong>感觉这种设计类的题目比那些脑筋急转弯的题目有意思多了, 希望leetcode能增加这类题目量.</strong>”，估计有人回复“脑筋急转弯的题目可以提高智商”(该回复已删除只能猜测大致的原话)，然后被一顿乱喷，笑死……</p>
<blockquote>
<p>别几把逗了 你靠leetcode提高智商 那弱智是不是都来这里治疗了？无非背几个题解过面试而已<br>没用 智商是多少就多少 刷题只能起到背题的作用 背的多了 就有思路了<br>爷笑了，LeetCode能提高智商。</p>
</blockquote>
<p><strong>收获：</strong></p>
<ul>
<li>了解了一些C++ STL相关操作的时间复杂度</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/wusecaiyun/article/details/46723363" target="_blank" rel="noopener">C++ STL标准容器插入删除算法的复杂度</a><br><a href="https://www.cnblogs.com/shona/p/10789721.html" target="_blank" rel="noopener">C++ STL中常见容器的时间复杂度</a></p>
</blockquote>
<ul>
<li>回顾了vector.push_back(x)，学习了vector.erase(x)的用法</li>
</ul>
<blockquote>
<p><a href="https://www.cnblogs.com/shiliuxinya/p/12219149.html" target="_blank" rel="noopener">从vector中删除指定元素</a><br><a href="https://blog.csdn.net/u014571489/article/details/82258769" target="_blank" rel="noopener">vector中去除指定元素</a><br><a href="https://www.jianshu.com/p/9676c6b877d2" target="_blank" rel="noopener">Vector中使用erase函数的分析</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清除某一位置的元素，清除第一个元素如下</span></span><br><span class="line">order.erase(order.begin());</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除某个元素，先查找，再删除，erase操作会自动调整数组内部元素的位置</span></span><br><span class="line"><span class="comment">//因为进行了for循环，所以删除的时间复杂度就是O(n)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter=order.begin(); iter!=order.end(); iter++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(*iter==key)&#123;</span><br><span class="line">    order.erase(iter);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>学习了map.erase(x)的用法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> iter=mp.find(key);</span><br><span class="line">mp.erase(iter);<span class="comment">//清除</span></span><br></pre></td></tr></table></figure>
<ul>
<li>学习了<strong>哈希链表</strong></li>
</ul>
<hr>
<p>2020.04.25</p>
<p>146-LRU Cache 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　本题是昨天做的题。因为昨天虽然学了本题的最优解法“哈希链表”，但是没有亲手去实现哈希链表。所以今天就再次用哈希链表再将本题写一遍。<br>　　整体写得很慢，因为对链表的细节基本上忘得差不多了，就边写边想。一开始先写了链表插入删除的函数，写到一半感觉不太对劲，然后才想起来要引入头结点、尾结点。<br>　　代码写完后，开始调试，代码书写错误都改完后，一运行就报了一长串错，错误第一行<code>==32==ERROR: AddressSanitizer: heap-use-after-free</code>, 我感觉意思就是在说在“释放内存后又去尝试使用该内存”。在我代码中，只有在删除链表结点这一函数中我使用了<code>delete</code>释放结点。但是使用<code>delete</code>并不应该会报错啊？在debug一会儿无果后，因为<code>delete</code>语句是否存在只会影响到使用的内存大小，并不影响程序流程，所以我只能先注释掉<code>delete</code>去运行。然而跑默认样例的结果是Wrong Answer，这说明是我代码的流程有问题。<br>　　再次查找bug，终于发现是因为<strong>对“哈希链表”进行删除操作的时候，我只删除了链表结点，没有删除hashmap结点</strong>。然后补充删除hashmap元素的代码，补充delete，这次默认样例通过了。提交，<strong>再次报错Runtime Error</strong>，错误原因 <code>AddressSanitizer: attempting free on address which was not malloc()-ed</code> 又是跟内存分配、释放有关系，说我“试图free一个未曾malloc过的内存空间”。突然我脑海中一闪，火速看了看刚才新增的代码，立刻就找到了错误：<strong>本来应该删除mp[key], 我写成了删除mp[value]</strong>。修改后，再次提交，通过，运行时间为188ms，远小于昨天的640ms。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改前</span></span><br><span class="line"><span class="keyword">auto</span> iter=mp.find(LHead-&gt;next-&gt;value);</span><br><span class="line">mp.erase(iter);<span class="comment">//删除哈希表冗余元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line"><span class="keyword">auto</span> iter=mp.find(LHead-&gt;next-&gt;key);</span><br><span class="line">mp.erase(iter);<span class="comment">//删除哈希表冗余元素</span></span><br></pre></td></tr></table></figure>
<p><strong>收获：</strong></p>
<ul>
<li>回顾了链表头结点、尾结点、插入、删除</li>
<li>回顾了C++ 删除对象的方法 delete、free，以及<a href="https://blog.csdn.net/weixin_39469127/article/details/82288994" target="_blank" rel="noopener">二者的区别</a></li>
</ul>
<blockquote>
<p>delete会调用类的析构函数和释放内存, 而free只是释放内存。<br>C++里一般都使用delete，因为new和delete是配套的</p>
</blockquote>
<ul>
<li>回顾了map.erase(x)的用法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> iter=mp.find(key);</span><br><span class="line">mp.erase(iter);<span class="comment">//清除</span></span><br></pre></td></tr></table></figure>
<ul>
<li>亲手实现了<strong>哈希链表</strong>这个查询、插入、删除均为$O(1)$的数据结构</li>
<li>牢记删除哈希链表的结点时，一定要同时删除链表和hashmap的结点</li>
</ul>
<p><br><br>55-Jump Game 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　刚看到这道题，感觉好像是用dfs或bfs，但是题目没有给数据范围，并且这种暴力做法不仅不优雅，而且一般情况下都会超时，所以我决定放弃这种思路。<br>　　然后我就在想怎么用dp做，想了一会儿没想出来。本来准备去看题解了，但是灵光一闪，发觉本题其实很简单。不用考虑其他任何东西，只用不断记录并更新一个最大值就行了。我不知道这种方法叫什么，但隐隐感觉像是<strong>贪心算法</strong>。</p>
<blockquote>
<p>创建一个变量maxIndex，用来记录当前所能到达的最大坐标。依次遍历每个数，比较maxIndex和i+nums[i]，取最大值更新maxIndex。如果遇到0，就查看maxIndex是否大于当前坐标i，如果能跨过这个0，就继续一步步向前，最后查看是否能到达终点。</p>
</blockquote>
<p>　　第一次提交WrongAnswer，被<code>[0]</code>卡住了。我以为是数组长度的问题，就在求数组长度后面直接加了一句<code>if(numsSize == 1) return true;</code>。第二次提交还是WrongAnswer，被<code>[2,0,0]</code>卡住了。我这才发现这两组数据的共同点在于终点元素都为0。恍然大悟，删除了第一次修改的语句，在for循环开始添加了一句判断当前是否已在终点 <code>if(i == numsSize-1) return true;</code>，遂通过。<br>　　提交成功后发现这居然是一道medium题，挺高兴的，之前没见过类似的题，依旧独立想出来了。官方题解只给了一种方法，称作“贪心”，与我之前的猜想完全一致，嘿嘿。</p>
<p><strong>收获：</strong> 无</p>
<hr>
<p>2020.04.26<br>1143-Longest Common Subsequence 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　最长公共子序列，非常经典的动态规划题目，虽然以前看过，但现在也忘得差不多了。这次就不折磨自己了，直接去看题解。首先去看了《挑战程序设计竞赛》电子版57页，代码没问题，但是列出来的dp式子第一行好像不太对，估计因为这个电子书是2013版的，回学校的时候看看我寝室的纸质版里有没有进行勘误(点击网页右侧“<a href="https://www.ituring.com.cn/book/1044" target="_blank" rel="noopener">提交/查看勘误</a>”)。而且此书对本题没怎么详细解释，于是我就转头直奔LeetCode讨论区了。比较不错的题解如下三个，后两个还<strong>额外介绍了一维数组的解法</strong>。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/solution/dong-tai-gui-hua-zhi-zui-chang-gong-gong-zi-xu-lie/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-subsequence/solution/dong-tai-gui-hua-zhi-zui-chang-gong-gong-zi-xu-lie/</a><br><a href="https://leetcode-cn.com/problems/longest-common-subsequence/solution/marvelzhong-deng-de-xue-xi-bi-ji-1143-by-tyanyon-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-subsequence/solution/marvelzhong-deng-de-xue-xi-bi-ji-1143-by-tyanyon-2/</a><br><a href="https://leetcode-cn.com/problems/longest-common-subsequence/solution/a-fei-xue-suan-fa-zhi-by-a-fei-8/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-subsequence/solution/a-fei-xue-suan-fa-zhi-by-a-fei-8/</a></p>
</blockquote>
<p>　　写代码时要<strong>额外注意</strong>：字符串在text数组与dp数组中“当前元素”对应的坐标不一致，因为text默认起始坐标为0，而为了方便处理边界dp数组就额外加了一行一列，所以dp数组默认起始坐标为1。比如text1[i]、text2[j] 对应的dp数组元素为 dp[i-1][j-1]，写代码的时候不要写错了。</p>
<p><strong>收获：</strong></p>
<ul>
<li>回顾了memset的用法</li>
<li>今天我突然发现，我在提交成功的代码里无意间定义并使用了一个变长数组  <code>int dp[m+1][n+1]</code>，然而在我印象中C/C++数组长度的定义<strong>只能是常数</strong>。这就让我十分好奇，就去网上查找了一番，找到了答案。我感觉是因为LeetCode的编译器兼容性很强才能让我的代码通过，所以我以后还是尽量用二维vector吧。</li>
</ul>
<blockquote>
<p>新的C++标准里定义数组时数组长度可以是变量了吗？ <a href="https://bbs.csdn.net/topics/391898322" target="_blank" rel="noopener">https://bbs.csdn.net/topics/391898322</a><br>——C 自 C99 开始，在特定条件下允许使用变量作为数组长度定义数组；C++ 至今不允许这种用法，C++中你只能用vector之类容器等代替</p>
</blockquote>
<hr>
<p>2020.04.27<br>221-Maximal Square 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　想了一会儿，暴力搜索写起来情况很多太麻烦了而且时间复杂度太高，放弃；因为是01矩阵，又想到了与或操作，完整流程想不出来，又放弃；看到“最大”二字，感觉可能是动态规划，有一点点思路但是卡住了，再次放弃，看题解去了。<br>　　题解给出的方法有暴力求解，但主要是动态规划。看了代码，我才发现我的dp思路跟题解的差不多，都是考虑当前元素左侧、左上角、上侧这三个相邻元素。不同的是，我设计的dp数组元素是“当前元素所在最大矩形的<strong>面积</strong>”，而题解里设计的dp数组元素是“当前元素所在最大矩形的<strong>边长</strong>”。<br>　　除此之外，本题与昨天的题相比，还额外绕了一个弯。昨天的题求“最长”，从头到尾一直<code>max()</code>，最后输出dp数组最后一个元素就行了。本题是求“最大”，按照昨天题的惯性思维去构思，很可能想的也是一直<code>max()</code>。然而实际做法是先<code>min()</code>，再用<code>max()</code>更新额外设置的一个变量maxLen，最后输出maxLen*maxLen。<br>　　还有要注意本题的代码结构。题解的做法是遍历一遍，<code>min()</code>与<code>max()</code>在同一次遍历中进行。也可以先二重循环遍历一遍，进行<code>min()</code>，然后再二重循环遍历第二遍，进行<code>max()</code>，就如同我在 2020.04.03 53-Maximum Subarray，以及2020.04.11 543-Diameter of Binary Tree 里那样的写法，增加了代码冗余和运行时长，不推荐，要有意识地避免这样的写。</p>
<p><strong>收获：</strong></p>
<ul>
<li>通过这两次遇到的动态规划题，我明白了<strong>对我而言</strong>学dp题的最好方式就是<strong>见多识广熟能生巧</strong>。因为很多dp题真的很难在第一次遇到的时候就能规划出一个明确的思路(比如那个“臭名昭著”的扔鸡蛋问题)，大部分情况下只能依靠以往的经验才能尽可能快地解答出来。</li>
</ul>
<hr>
<p>2020.04.28<br><a href="https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/531/week-4/3313/" target="_blank" rel="noopener">First Unique Number</a> 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　又是一道OOD(Object-Oriented Design)题目，而且<strong>本题又是一道不在题库中的新题</strong>。由此我发现参加LeetCode英文版这边的活动更容易碰到新题。因为是设计类题目，所以题意就很直接。然后看数据限制，数据数量不超过$10^5$个，但是操作数要求不超过$5*10^4$次，也就是说时间复杂度要小于$O(n)$。<br>　　提取本题要点：<strong>“增加”、“查询”、“自定义排序”、“尽量缩减操作数”</strong>… 很明显，本题与 2020.04.25 146-LRU Cache 基本上是同一类题目，自然而然想到的方法就是<strong>哈希双向链表</strong>。<br>　　于是我就依照上次的经验进行书写，经过一段时间后写完，跑第二个样例进行debug时发现答案错误。经过思考发现是我对于重复元素的处理太简单粗暴了，最初我的写法是，<strong>当遇到重复的元素时，就从把它从链表中移动到链表最末尾</strong>，因为它重复后就已经无用了。但是，新插入的元素同样也是插入到链表尾部，这样的话，重复的无用元素可能会排在新插入的元素之前，严重影响了新元素的排序。<br>　　既然重复过的元素无用了，从链表直接删除可以吗？也不行，因为当第二次遇到某个元素就把它从链表删除掉，那么第三次遇到的时候，map就会访问到一个已经被释放的内存，程序必然会出错。那么删除链表结点的时候，同时把map里的结点也同时删除掉可以吗？更不行了，因为这样做的话，第三次遇到同样的元素，map里不存在，就会把它当做一个新元素插入，错上加错。<br>　　那应该怎么办呢？稍加思索，我设计出了一个非常巧妙的方法：<strong>伪删除</strong>——就是只修改链表中要删除的元素的前后结点的指针指向，绕过这个要删除掉的元素，但是并不释放掉该结点内存。这样的话，既不影响后续新元素的排序，第三次遇到的时候也能通过map访问到这个结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">被注释掉的第一版代码，作用是不断把重复元素移动到链表末尾</span></span><br><span class="line"><span class="comment">void moveToTail(LinkListNode* LNode)&#123;</span></span><br><span class="line"><span class="comment">    if(listLen == 1) return;</span></span><br><span class="line"><span class="comment">    LNode -&gt; pre -&gt; next = LNode -&gt; next;</span></span><br><span class="line"><span class="comment">    LNode -&gt; next -&gt; pre = LNode -&gt; pre;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    tail -&gt; pre -&gt; next = LNode;</span></span><br><span class="line"><span class="comment">    LNode -&gt; pre = tail -&gt; pre;</span></span><br><span class="line"><span class="comment">    LNode -&gt; next = tail;</span></span><br><span class="line"><span class="comment">    tail -&gt; pre = LNode;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteLink</span><span class="params">(LinkListNode* LNode)</span></span>&#123; <span class="comment">//删除第二次出现的结点</span></span><br><span class="line">    LNode -&gt; pre -&gt; next = LNode -&gt; next;</span><br><span class="line">    LNode -&gt; next -&gt; pre = LNode -&gt; pre;</span><br><span class="line">    listLen--;</span><br><span class="line">    <span class="comment">//这里不用delete释放内存</span></span><br><span class="line">    <span class="comment">//因为只是象征性地删除这个结点，避免它影响排序</span></span><br><span class="line">    <span class="comment">//而后续再次add时，依旧可以访问到这个结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　然后逛了一下讨论区，发现了<a href="https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/531/week-4/3313/discuss/601199/LRU-Cache-Logic-HashMap-+-Doubly-LinkedList" target="_blank" rel="noopener">一个贴子</a>与我的思路基本一致，用的是哈希双向链表。更凑巧的是，<strong>他竟然也用了“伪删除思想”</strong>。该贴评论区的第一条就在在质疑这个“删除”，问道“如果删除结点，第三次遇到一个值，会访问不存在的地址”，楼主之后对“伪删除”进行了解释。该贴下，也有其他人提出了另一种做法，就是再设置一个set保存所有元素，而map只存储着唯一存在的元素，这样删除链表结点的同时也可以删除map结点了。</p>
<p><strong>收获：</strong></p>
<ul>
<li>复习了哈希双向链表</li>
<li>本题���������������������������又一次忘了用unordered_map了</li>
<li>发现了vscode垂直列选的快捷键是<code>alt+shift+左键</code>。以前在notepad++中的快捷键是<code>alt+左键</code>，刚开始用vscode的时候用这个快捷键发现没用，还以为vscode没有这个功能，今天才知道只是快捷键不一样罢了</li>
</ul>
<hr>
<p>2020.04.29<br>124-Binary Tree Maximum Path Sum 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　第一眼看上去，感觉本题与2020.04.11 543-Diameter of Binary Tree 基本上就是同一类型的题目，就立刻开始上手去写了。写的过程中发现思路、代码结构几乎就一模一样，这次写代码时我就吸取了上次的教训，直接创建了一个全局变量maxSum用来记录，并在同一个递归函数里进行更新。<br>　　第一版代码写完进行测试，发现答案不对。想了一会儿，发现是我的思路有一点瑕疵：我选择 <code>maxSum, root-&gt;val, root-&gt;val+leftVal, root-&gt;val+rightVal</code> 这四个值中的最大值来更新maxSum。然而实际上在取最大值的过程中，应该再加入一个 <code>root-&gt;val+leftVal+rightVal</code> 进行比较。代码进行修改后，提交成功。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一版错误代码</span></span><br><span class="line">root-&gt;val = max(root-&gt;val, max(root-&gt;val+leftVal, root-&gt;val+rightVal));</span><br><span class="line">maxSum = max(maxSum, root-&gt;val);</span><br><span class="line"><span class="keyword">return</span> root-&gt;val;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二版代码，这次先更新maxSum，再更新root-&gt;val</span></span><br><span class="line">maxSum = max(maxSum, max(root-&gt;val+leftValrightVal, max(root-&gt;val, max(root-&gt;val+leftVal, root-&gt;va+rightVal))))</span><br><span class="line">root-&gt;val = max(root-&gt;val, max(root-&gt;val+leftVal, root-&gt;val+rightVal));</span><br><span class="line"><span class="keyword">return</span> root -&gt; val;</span><br></pre></td></tr></table></figure>
<p>　　整道题写起来基本上可以说很轻松，思路很快想出来，代码量也不大。当我以为本题和 543-Diameter of Binary Tree同样为easy题时，竟然发现本题难度为hard……无语，上一次我写 543-Diameter of Binary Tree 时写得磕磕绊绊，以为至少是 medium，结果是easy；本题思路与 543-Diameter of Binary Tree 基本一致，写得很顺利，以为同样是easy，却是hard……评论区题解基本上也是同样的思路就没什么好说的了。</p>
<p><strong>收获：</strong></p>
<ul>
<li>复习了二叉树的相关操作</li>
</ul>
<hr>
<p>2020.04.30<br><a href="https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/532/week-5/3315/" target="_blank" rel="noopener">Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree</a> 题目顺序类别: 30-Day LeetCoding Challenge  2020.04</p>
<p><strong>随记：</strong><br>　　又是一道不在题库里的新题。题意很简单，看了一眼就能很快想出一个完整的dfs思路。但是又看到下面标明数据量不大于5000，对于dfs来说这样已经是很大的数据量了，遂放弃这个思路了。之后想了想其他方法，无果。然后突然看到题目下方的提示说用dfs做，这就让我很无语……说明dfs确实是本题的解法，于是我就想，是不是可以剪枝呢？想了一下，发现好像的确是可以剪枝的：<strong>如果当前二叉树结点不等于arr[index]，则该结点的所有的后继结点都被剪掉了，就不用再探索了</strong>。<br>　　顺着这个想法快速写了一遍，改了一点bug，提交，通过。30天挑战最后一天的题居然这么简单，很是意外。我发现英文版LeetCode这边真是大方，同样是30天挑战，英文版是每天10分即+10<em>30，完成25天+100，完成30天+200，共计+600币。中文版每天10分即+10</em>30，完成30天+100，共计+400币。除此之外，英文版5000币换一个月会员，中文版2000币换7天会员，真的抠门……</p>
<p><strong>收获：</strong></p>
<ul>
<li>回顾了dfs中的“剪枝”思想</li>
</ul>
<hr>
<p>2020.05.01<br>278-First Bad Version 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　稍微看两眼，就很轻易地知道是二分查找。只不过不同于常见的二分查找，本题二分查找的是左侧边界。由于本题输入序列可转化为<code>false false false true true ...</code>，所以本题代码里二分查找模板的 ‘target’ 对应的就是 ‘true’ 。套<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/er-fen-cha-zhao-xiang-jie" target="_blank" rel="noopener">模板</a>，一遍过。</p>
<p><strong>收获：</strong></p>
<ul>
<li>回顾了二分查找左侧边界</li>
</ul>
<hr>
<p>2020.05.02<br>771-Jewels and Stones 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　我感觉这种题过于简单，就不应该出现在LeetCode题库里。因为题目里J中的每个字符都不相同，所以我用的是map写的，提交4ms。我看别人0ms代码用的是set。</p>
<p><strong>收获：</strong></p>
<ul>
<li>用下标[ ]访问string返回的数据类型是char，我以前一直<strong>错以为</strong>即使是string的单个字符，类型也是string (<strong>2020.5.22补记</strong>：写了一些java代码才发现，在java里的string和char才是泾渭分明的，要用String.toCharArray()方法，将String 转化为 字符串数组，或者使用 String.charAt(index) 方法，返回在index位置的char字符)</li>
<li>我又忘了用unordered_map</li>
<li>题目涉及到唯一性，记得用set</li>
</ul>
<hr>
<p>2020.05.03<br>771-Jewels and Stones 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　一开始我只是浏览了一下题目描述，以为是一个用map一分钟就写出来的代码题。然后我看了看样例，发现好像不对，这貌似是个<strong>字符串匹配</strong>问题。于是就想起了kmp算法，然后花费了两个小时去看kmp算法的讲解。看完一些kmp算法的讲解之后，我想着去LeetCode题解区看看其他人的kmp讲解，<strong>令我万万没想到的是</strong>，发现本题就是个用map写的简单<strong>字符序列匹配</strong>，跟我最初的想法一模一样……唉，如果题目给的第三个样例由<code>canConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true</code>改为<code>canConstruct(&quot;aa&quot;, &quot;aba&quot;) -&gt; true</code>我就绝对不可能把题意理解错。真无语，花了那么长时间去看kmp算法，结果最后压根没用上……<br>　　还是回顾一下我今天重新学kmp的过程吧。首先，去看了labuladong的算法小抄的<a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-zhi-kmp-zi-fu-pi-pei-suan-fa" target="_blank" rel="noopener">《动态规划之KMP字符匹配算法》</a>。对于这篇讲解，真的很震惊，因为它与以往我所见到的任何<a href="https://www.zhihu.com/question/21923021" target="_blank" rel="noopener">讲解kmp算法的思路</a>都不同，它是以“状态机”的角度去阐述kmp算法。而这个所谓的“状态机”原来基本上就类似于我所熟悉的数字逻辑中的“状态转化图”，这样一来算法的流程对我而言就显得十分清晰。我很早以前就知道一个用来处理字符串的算法“AC自动机”，今天才了解到“状态机”是什么。不过我看到最后还是感觉有点迷糊，并且也有人对该文章的细节之处<a href="https://github.com/labuladong/fucking-algorithm/issues/274" target="_blank" rel="noopener">提出了质疑</a>，我看了看感觉该质疑确实也很有道理。同时也有人说该文章的做法有点“多余”，因为它把以往的一维next数组换成了一个二维的dp数组。<br>　　于是我就去网上搜了搜其他的kmp讲解。在<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">《字符串匹配的KMP算法》</a>这篇博文下方，我看到有人评论说 “Robert Sedgewick <a href="https://class.coursera.org/algs4partII-001/lecture/40" target="_blank" rel="noopener">https://class.coursera.org/algs4partII-001/lecture/40</a> 用自动机解释kmp，感觉更妙，就是实现的时候空间复杂度高点。个人感觉Sedgewick这个老头讲东西确实牛逼，很多看书很难理解的算法，他一讲就明白了，有兴趣的可以去part1看看他讲的红黑树，特别牛逼”，随后我就去Coursera上找到了该课程的<a href="https://www.coursera.org/lecture/algorithms-part2/introduction-to-substring-search-n3ZpG" target="_blank" rel="noopener">最新地址</a>，发现原来“labuladong的算法小抄”文章的思路就是出自于该课程。后来又看了一些文章，感觉<a href="https://www.zhihu.com/question/21923021/answer/281346746" target="_blank" rel="noopener">这篇知乎回答</a>用传统的思路解释得非常好，值得反复阅读学习 。</p>
<p><strong>收获：</strong></p>
<ul>
<li>莫名其妙复习了一遍kmp算法</li>
</ul>
<hr>
<p>2020.05.04<br>476-Number Complement 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　题意就是把一个数的二进制逐位求反。在做过 201-Bitwise AND of Numbers RangeBitwise AND of Numbers Range 之后，我对这类“位运算”的题目就有了一些思路，所以本题很快就想出了解法：num为奇数时，代表当前最低位是1，为了求反把0入栈，num右移一位；num为偶数时，代表当前最低位是0，为了求反把1入栈，num右移一位，往复循环直到num为0。然后不断出栈，组成一个新的数字就是答案了。</p>
<p><strong>收获：</strong></p>
<ul>
<li>回顾了位运算</li>
<li><strong>注意</strong> “num右移” 的写法不是 <code>num &gt;&gt; 1;</code>，而是 <code>num = num &gt;&gt; 1;</code></li>
</ul>
<hr>
<p>2020.05.05<br>387-First Unique Character in a String 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　一开始我以为本题和 136-Single Number 是一模一样的题，只不过把数字改成了字符，然后就用异或的方法写了一遍。写完后测试的时候发现不对，这才注意到本题是<strong>“第一个”独特的字符</strong>，这意味着独特的字符并不只有一种，所以异或的方法是不行的。<br>　　然后我就用unordered_map做了一遍，提交成功，只不过耗时100ms有点长。我看了看其他耗时很只有36ms的代码，发现我们的思路是一致的，只不过他们没有用hashmap，而是直接开了一个<code>int count[26];</code>数组，因为本题有说string里所有的字符都是小写字母，所以才能这么做。用数组进行操作自然节省了很多的时间。<br><strong>收获：</strong></p>
<ul>
<li>回顾了异或的符号是<code>^</code></li>
</ul>
<hr>
<p>2020.05.06<br>169-Majority Element 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　很简单的一道题，用hashmap在$O(n)$时间复杂度就能处理。不过后来看官方题解看到了另一种做法，思路很巧妙，就是用$O(n\ log\ n)$时间复杂度的排序算法对数组进行排序，然后直接返回下标为$\lfloor \frac n 2 \rfloor$的元素，就必定是“出现次数大于$\lfloor \frac n 2 \rfloor$的数字”<br><strong>收获：</strong></p>
<ul>
<li>学习了Mathjax中向下取整 <code>$\lfloor  \rfloor$</code> ，分数<code>$ \frac n 2 $</code></li>
</ul>
<hr>
<p>2020.05.07<br>993-Cousins in Binary Tree 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　比较简单的一道二叉树题目。关于二叉树的题目，最常见的套路就是“dfs+全局变量”去解题。本题亦然，只不过需要记录的数据有点多，也不方便都用全局变量来记录，于是就只好作为参数传递，最终dfs函数的参数高达5个。<br>　　提交，一遍过。点击<a href="https://leetcode.com/submissions/detail/335718637/" target="_blank" rel="noopener">提交详情页面</a>的第一条圆柱查看别人的代码，发现与我的代码思路、格式惊人的一致，嘿嘿。</p>
<p><strong>收获：</strong></p>
<ul>
<li>看了以前用typora写的一篇markdown文章，才发现原来“引用”里是可以加空行的，只是一直不知道而已，因为typora“所见即所得”的特性掩盖了底层代码实现的原理。</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;AAAAAA</span><br><span class="line">&gt;</span><br><span class="line">&gt;BBBBBB</span><br></pre></td></tr></table></figure>
<blockquote>
<p>AAAAAA</p>
<p>BBBBBB</p>
</blockquote>
<hr>
<p>2020.05.08<br>1232-Check If It Is a Straight Line 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　非常简单的一道题，只要知道初中数学斜率公式就能很轻松地写出来。虽然我的代码通过了，但是在评论区的讨论中我发现我的代码还是有问题的：我是直接用的相除形式的公式，然而这可能会出现一个问题，就是分母为0，所以应该把除法转换为乘法 <code>(y1-y0)/(x1-x0)==(yi-y0)/(xi-x0) 防止除0，变换成相乘的形式 (y1-y0)*(xi-x0)==(yi-y0)*(x1-x0)</code></p>
<p><strong>收获：</strong> </p>
<ul>
<li>写除法代码的时候要避免分母为0</li>
</ul>
<hr>
<p>2020.05.09<br>367-Valid Perfect Square 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　本题的难点在于不让用库函数<code>sqrt()</code>，我依稀记得学C语言的时候在课本上学过类似的题，当时用的方法叫“牛顿迭代法”，于是我就去搜了一下这个方法的具体实现。在搜索的同时，我发现<a href="https://www.cnblogs.com/wangkundentisy/p/8118007.html" target="_blank" rel="noopener">一篇博文</a>里同时提到了另一种常见的开根号算法：二分查找。对比了一下两个方法，因为对二分更熟悉，所以我就选择用二分去做。三下五除二写完，代码如下，测试了几个样例也都通过了，提交的结果却是<strong>Runtime Error</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = num;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid * mid == num)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid * mid &lt; num)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid * mid &gt; num)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Runtime Error Message:<br>Line 9: Char 20: runtime error: signed integer overflow: 1073741824 * 1073741824 cannot be represented in type ‘int’ (solution.cpp)<br>SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:20</p>
<p>Last executed input:<br>2147483647</p>
</blockquote>
<p>　　仔细查看报错信息，发现原来是整型溢出了。输入的这个2147483647就是int类型的最大正整数值，<code>1073741824 * 1073741824</code> 自然会溢出。于是我额外添加了一个unsigned long long变量来存储输入的int类型num，然后把上文代码里所有的int都改为unsigned long long。提交，通过。看了看评论区，发现别人的代码并没有用unsigned long long，而是巧妙地运用了除法来避免整型溢出 <code>mid * mid == num 改为 mid == num / mid</code>。</p>
<p><strong>收获：</strong></p>
<ul>
<li>二分法开根号</li>
<li>用除法来规避乘法造成的整型溢出，这样的做法就相当于二分模板里 <code>int mid = left + (right - left) / 2;</code> 通过减法来避免加法溢出</li>
</ul>
<hr>
<p>2020.05.10<br>997-Find the Town Judge 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　初看像是“图”相关的问题，但是感觉建图太麻烦了就试着往其他方向想，发现两个map就能解决。很快地就把代码写出来了，测试样例无误，但提交却是Wrong Answer，老问题被“输入的vector为空”这种情况卡住了。要额外注意，本题当trust为空时有两种情况，若N=1返回1，若N!=1返回-1。<br>　　看了看评论区，有一些人思路跟我一致；另一些人选择建图去做，利用“入度”“出度”这两个概念进行解题。</p>
<p><strong>收获：</strong></p>
<ul>
<li>复习了map的遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter = mp.begin(); iter != mp.end(); iter++) &#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;iter -&gt; first &lt;&lt; iter -&gt; second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>2020.05.11<br>733-Flood Fill 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　看了看题，颜色填充，就是一道简单的dfs，与 200-Number of Islands 基本一致，于是我就迅速上手码了一遍。跑样例通过，第一次提交Wrong Answer。发现是漏写了一句话，在进入dfs()之前没有将起始点的颜色修改。<br>　　在进入dfs()前补上<code>G[sr][sc] = newColor;</code>，第二次提交Runtime Error，我没仔细看错误信息，以为是数组越界了，但是我就非常奇怪，因为上一次写200-Number of Islands 的时候我犯过这样的错误，所以这次我对数组越界格外注意。检查了半天也没找到代码上的错误，于是我就写了一句cout打印了一下经过的坐标点，这才发现输出的坐标陷入了死循环，就是无限递归，也就是栈溢出了，正好符合我忽视掉的错误提示“stack-overflow”。<br>　　这时才发现代码少设置了一个flag数组来标记是否经历过某一点。漏写是因为上次写200-Number of Islands 时，提前设置了一个flag，后来发现没用删掉了。然后我保持着上次的记忆，这次写代码前就没有设置flag数组，翻车了。设置flag数组后，第三次提交又是Runtime Error，这次是因为我只在进入dfs之前对起始点的flag做了标记，忘了在dfs()函数内写一句修改flag标记……在dfs()函数内补上，第四次提交，通过。<br>　　然后看了看题解，<a href="https://leetcode-cn.com/problems/flood-fill/solution/zhe-chong-ti-du-you-kuang-jia-de-nei-fu-xiang-jie-/" target="_blank" rel="noopener">这篇题解</a> 就讲述了“陷入无限循环”的问题，解决方式就是设置一个visited数组。之后又在评论区发现一个可以节省时间的小技巧：当修改颜色和初始颜色一样时，可以直接返回原数组。<br>　　但令我奇怪的是，评论区的很多代码都没有设置flag数组或visited数组。直到我看了<a href="https://leetcode-cn.com/problems/flood-fill/solution/di-gui-jiu-wan-shi-liao-4ms-9876-by-int-myheart/" target="_blank" rel="noopener">这个用户的话</a>，才想起来我写代码之前研究了一下，发现本题用不到flag数组，所以才没写，而并不是漏写了。之所以会Runtime Error，就是因为我没有在“修改颜色和初始颜色一样时直接返回原数组”，回看了我Runtime Error提交记录的输入样例，恰恰就是“修改颜色和初始颜色一样”的情况。<br>　　所以本题要避免Runtime Error，只有两种方法：1.像<a href="https://leetcode-cn.com/problems/flood-fill/solution/zhe-chong-ti-du-you-kuang-jia-de-nei-fu-xiang-jie-/" target="_blank" rel="noopener">这篇题解</a> 设置visited数组做标记；2. 不设置visited标记数组，而是选择“修改颜色和初始颜色一样时直接返回原数组”。总得来说第二种方法还是特殊了一些，仅适用于本题。一般情况下写dfs题目，最好是先设置一个visited数组。</p>
<p><strong>收获：</strong></p>
<ul>
<li>复习了二维vector的初始化、赋值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flag.resize(rows);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) flag[i].resize(columns);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rows; j++)</span><br><span class="line">     flag[i][j] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>遇到bug时，时刻谨记用cout输出过程中的数据来查错，必要时可以用到“二分查错法”</li>
</ul>
<hr>
<p>2020.05.12<br>540-Single Element in a Sorted Array 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　刚看到本题，还以为是跟136-Single Number一样用异或解题。然后发现题目下方有一个要求，限制本题时间复杂度为$O(log\ n)$，空间复杂度为$O(1)$。再回顾一遍题干发现本题的两大要点为：1.输入的数组已排序好；2.时间复杂度为$O(log\ n)。很明显本题要用二分查找去做，然而题目并没有给一个target，所以我思考了半分钟发现不会做，就果断去看题解了……<br>　　看了看官方题解方法三的代码，这个二分查找和<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/er-fen-cha-zhao-xiang-jie" target="_blank" rel="noopener">平常用的模板</a>不太一样。而且把题解代码里if、else的判断语句交换后，输出就立刻错了，我也没理解是为什么，最后只能按照题解代码写了一遍提交了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid % <span class="number">2</span> == <span class="number">1</span>) mid --;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] == nums[mid + <span class="number">1</span>])</span><br><span class="line">        left = mid + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        right = mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 为什么是 &lt; 而不是 &lt;=</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="keyword">if</span>(mid % <span class="number">2</span> == <span class="number">1</span>) mid --; </span><br><span class="line">这一句是模板里没有的，我感觉我想不出来</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 如果写成下面这样的形式，答案就是错的，为什么？</span><br><span class="line"><span class="keyword">if</span>(nums[mid] == nums[mid - <span class="number">1</span>])</span><br><span class="line">  right = mid;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">  left = mid + <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>收获：</strong></p>
<ul>
<li>本题很难，待补</li>
</ul>
<hr>
<p>2020.05.13<br>402-Remove K Digits 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　第二个让我崩溃掉的题目（上一个是678-Valid Parenthesis String）。初看到本题想了一会儿，发现本题好像就是贪心算法，就顺着思路写了一遍，测试题干所给的三个样例，都过了。提交的时候却出现了<strong>匪夷所思的情况</strong>——提交结果显示Wrong Answer，但是我把错误点的输入数据放在我提交的代码里运行，跑出来的结果却是正确的。也就是说<strong>同一个数据，我在测试代码的时候输出是A，是正确的；但是当我提交的时候，却报错显示我代码运行的结果是B</strong>。这就很让人匪夷所思了，同样的代码，同样的数据，为什么测试的运行结果和提交运行的结果不一样呢？</p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_43967679/article/details/105766221" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43967679/article/details/105766221</a><br><a href="https://blog.csdn.net/Tomwildboar/article/details/85933955" target="_blank" rel="noopener">https://blog.csdn.net/Tomwildboar/article/details/85933955</a></p>
<p>找到了两篇博客，但是并没有解决我的问题<br>1.我没有使用过static<br>2.如果我的代码是错误的，为什么测试的结果是对的呢？</p>
</blockquote>
<p>　　反复提交多次后，发现在页面最下方出现了一行小字，”Note: is Run Code inconsistent with Submit Solution? If you are using global variables or C/C++, check this out.”，貌似就是描述我这种情况的。打开<a href="https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-" target="_blank" rel="noopener">链接</a>，文章说当用C++时，可能是数组越界导致的这种情况。之后我反复检查了代码，都没有发现越界的情况，又添加了一点代码严格限制越界，然而情况依旧。<br>　　没办法只好删除所有代码，再按照原思路重新写一遍。这次我把某些语句换了另一个方式表达，比如for换成while，数组换成vector等。这一次提交还是Wrong Answer，只不过错误点的数据变了，不过这组数据再进行测试，结果是错的，说明我代码的思路确实错了。所以可能就是错误思路的代码+一些未知原因导致了上文诡异的状况。<br>　　之后又加了一些if else语句，又修修补补提交了几次，总是有数据不能通过。最后我放弃修改代码，直接去看官方题解了。在官方题解里，我看到确实用到了“贪心算法”，但是更重要的是本题还用到了“单调栈”，这一点我是真的没想到，我本以为顺序循环思路就能解决，没想到还用到了递归思路。除此之外，本题还有不少需要深度思考才能发现的边界条件，这就更增加了本题的难度。看完官方题解后，照着 <a href="https://leetcode-cn.com/problems/remove-k-digits/solution/bi-jiao-xiang-xi-de-cfang-fa-by-yin-feng-qian-chan/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-k-digits/solution/bi-jiao-xiang-xi-de-cfang-fa-by-yin-feng-qian-chan/</a> 的代码写了一遍提交了。</p>
<p><strong>收获：</strong></p>
<ul>
<li>从别的代码里知道了原来string也有str.empty()、str.pop_back()函数</li>
<li>学会了调用翻转字符串函数<code>reverse(str.begin(),str.end());</code></li>
</ul>
<hr>
<p>2020.05.14<br>402-Implement Trie (Prefix Tree) 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　今天的题是一道ODD题目，初看本以为很高深不会做，实际上就是一个字典树而已，每个结点的有26个孩子结点。好好注意细节，就是代码量稍微大了一点点，本质上不难的，即使定位是medium，提交一遍过。<br>　　看了一下<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/trie-tree-de-shi-xian-gua-he-chu-xue-zhe-by-huwt/" target="_blank" rel="noopener">题解</a>，感觉跟我的代码基本一致。</p>
<p><strong>收获：</strong></p>
<ul>
<li>本来想投机取巧，用<code>TreeNode* child[26] = {NULL}</code>一次性给26个元素赋值，查了一下int数组的初始化方式，才发现这样不行，只好乖乖地用for循环挨个初始化指针了</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始化</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;&#125;;    <span class="comment">//[0, 0, 0, 0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全部初始化为0</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;    <span class="comment">//[0, 0, 0, 0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，想要整型数组 全部初始化为1的时候不能粗暴的设置为 </span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>&#125;;    <span class="comment">//[1, 0, 0, 0, 0]</span></span><br></pre></td></tr></table></figure>
<hr>
<p>2020.05.15<br>918-Maximum Sum Circular Subarray 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　本题与 53-Maximum Subarray 题意基本一致，只不过本题的数组是“循环数组”。但正是这一个条件的改变，令我对如何处理本题感到很棘手，因为想出来的暴力方案时间复杂度好像是$O(n^n)$，实在太蠢了……于是就直接去看题解了。(我的思路是：先求一遍A[0…length-1]的Maximum Subarray；然后把A[0]拼接到A[length-1]的后面，再求一遍A[1…length-1,0]的Maximum Subarray;以此类推，最后一次求一遍A[length-1,0,1…length-2]，总共N个Max值，取其中最大的)<br>　　看了题解才知道原来 53-Maximum Subarray动态规划的解法还有个名字，叫Kadane算法。不过官方题解写得有点复杂，而且翻译好像是机翻的，不太容易理解，就没看了。首先看了一位<a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/solution/dong-tai-gui-hua-dui-ou-wen-ti-python3-by-smoon198/" target="_blank" rel="noopener">用户写的题解</a>，没能够理解其意思。直到我看到<a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/solution/dong-tai-gui-hua-zui-da-zi-duan-he-fen-zhi-si-xian/" target="_blank" rel="noopener">另一篇题解</a>里的图示，瞬间就明白了前一篇题解的含义。代码可以参照第一篇题解的代码去写。<br>　　测试的时候报错<code>AddressSanitizer: heap-buffer-overflow on address</code>,发现是数组越界了。改了之后提交Wrong Answer，cout数据，发现是判断“数组是否全是负数”这一点上出错了。因为我并没有完全照抄<a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/solution/dong-tai-gui-hua-dui-ou-wen-ti-python3-by-smoon198/" target="_blank" rel="noopener">第二篇题解</a>，所以我写的这判断和他不一样，然后就出错了。我一开始写的是  <code>if(sum == Min)</code>，后来发现如果A数组有正数的情况下，该if语句也可能成立。修改后的代码额外设置了一个allNegative来标记，<code>if(allNegative)</code>。</p>
<p><strong>收获：</strong></p>
<ul>
<li>学会了vector初始化并赋值 <code>vector&lt;int&gt; dp(ASize, 0);</code></li>
<li>回顾了求vector的最大元素 <code>*max_element(A.begin(), A.end());</code></li>
</ul>
<hr>
<p>2020.05.16<br>328-Odd Even Linked List 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　本题虽然是medium，但不难。因为曾经做过 876-Middle of the Linked List，接触到了“快慢指针”的思想，所以这次在画板上画了画，就发现本题同样用两个指针就能做出来。只不过一开始测试的时候有个样例报错 <code>runtime error: member access within null pointer of type &#39;ListNode&#39;</code>，去搜了一下，发现<a href="https://blog.csdn.net/shanghx_123/article/details/86445183" target="_blank" rel="noopener">一篇博客</a>里写道“试图使用空指针”，按我的理解就是说“把NULL当成一个结点去使用了”。用了个cout语句查错，发现是while循环判断语句写错了，于是把<code>while(even -&gt; next != NULL)</code> 改成 <code>while(even != NULL)</code>。样例都通过了，提交还是Runtime Error，又查错发现还是所写的while语句不对，最终改成<code>while(even != NULL &amp;&amp; even -&gt; next != NULL)</code>，提交通过。看了看官方题解，思路完全一致。</p>
<p><strong>收获：</strong></p>
<ul>
<li>回顾了用双指针解链表题的思路</li>
</ul>
<hr>
<p>2020.05.17<br>438-Find All Anagrams in a String 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　本题与 49-Group Anagrams 非常相似。没有什么更好的思路，于是写了个暴力解，每次找到长度相同的字符串后进行匹配，提交Time Limit Exceeded。<br>　　直接去看题解，这才发现本题用到的算法思路原来就是大名鼎鼎的“滑动窗口”。按照题<a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/20200321438median-by-jasion_han-r/" target="_blank" rel="noopener">解区的代码</a>，边码边理解。这篇题解的代码比<a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/hua-dong-chuang-kou-tong-yong-si-xiang-jie-jue-zi-/" target="_blank" rel="noopener">labuladong给的模板</a>简洁不少。</p>
<p><strong>收获：</strong></p>
<ul>
<li>回顾了string内部排序 <code>sort(str.begin(), str.end());</code></li>
<li>学习了了string取子串<code>str.substr(i, n) // i 子串起始坐标，n 子串长度</code></li>
<li>学习了“滑动窗口”，并且在浏览各种文章的过程中，知道了“滑动窗口”主要应用于子串匹配问题</li>
</ul>
<hr>
<p>2020.05.18<br>567-Permutation in String s题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　本题与昨天的 438-Find All Anagrams in a String 基本上一模一样，都是滑动窗口的题目，代码稍微改一下提交就过了。</p>
<p><strong>收获：</strong></p>
<ul>
<li>回顾了滑动窗口算法思想</li>
</ul>
<hr>
<p>2020.05.19<br>901-Online Stock Span 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　初看本题，感觉像是一道dp题。脑子有点混乱，想了一会儿没想出一个完整的dp思路。然后又画图，用本题去类比560-Subarray Sum Equals K，无果。接着又琢磨了一会儿用大顶堆小顶堆什么的。耗费大概15分钟，决定去看题解。<br>　　万万没想到的是，我刚把中文体面看了一遍，突然就有灵感了。就迅速用dp的思路码了一遍，提交通过了！！！回看题解区，官方题解是用的“单调栈”，不过有趣的是下面评论说官方题解代码超时……又翻了翻，终于找到一篇<a href="https://leetcode-cn.com/problems/online-stock-span/solution/javashuang-listtiao-yue-ji-suan-by-hteason/" target="_blank" rel="noopener">与我思路一致的代码</a>。</p>
<p><strong>收获：</strong></p>
<ul>
<li>测试样例时报错：heap-buffer-overflow，查错后发现还是数组越界问题</li>
</ul>
<hr>
<p>2020.05.20<br>230-Kth Smallest Element in a BST 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　dfs中序遍历二叉搜索树的同时存储结点值到一个vector中，然后直接返回下标为k-1的vector元素即可。感觉好久没有这么快地写出一道题了。半分钟不到代码就写完了。</p>
<p><strong>收获：</strong></p>
<ul>
<li>在<a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/solution/er-cha-sou-suo-shu-zhong-di-kxiao-de-yuan-su-by-le/" target="_blank" rel="noopener">官方题解</a>的评论区学到一个对本题dfs进行剪枝的方法：“当我们取到第k个元素时就终止递归”。</li>
</ul>
<hr>
<p>2020.05.21<br>1277-Count Square Submatrices with All Ones 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　本题与221-Maximal Square基本一致，甚至更简单一点，所以今天很快就能想到思路。提交也是一遍过的。但是在提交之前进行样例测试的时候，却遇到了几个问题。</p>
<ul>
<li>第一次运行就遇到报错</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Line <span class="number">9</span>: Char <span class="number">51</span>: fatal error: no viable overloaded <span class="string">'='</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columns; i++) dp[<span class="number">0</span>][i] = matrix[<span class="number">0</span>][i];</span><br><span class="line">                                         ~~~~~~~~ ^ ~~~~~~~~~~~~</span><br></pre></td></tr></table></figure>
<p>经过排查，发现是因为我对二维vector的初始化操作有遗忘，所以写错了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改前</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp[rows][columns];</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line"><span class="comment">//二维数组初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line">dp.resize(rows);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">    dp[i].resize(columns);</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个样例输出有问题，经过排查发现是因为dp推导式写错了……应该是先求最小值然后再加1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改前</span></span><br><span class="line">dp[i][j] = min(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line">dp[i][j] = min(dp[i][j - <span class="number">1</span>], min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二个样例输出结果少了，经过排查，发现是因为仅仅在后面填充dp数组的时候对sum进行更新，忘了在初始化dp数组的第一行和第一列的部分添加更新sum的语句，所以导致结果有遗漏</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改前</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columns; i++)</span><br><span class="line">    dp[<span class="number">0</span>][i] = matrix[<span class="number">0</span>][i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">    dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columns; i++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][i] = matrix[<span class="number">0</span>][i];</span><br><span class="line">    sum += dp[<span class="number">0</span>][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>];</span><br><span class="line">    sum += dp[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改上一个bug后，又发现第二个样例输出结果多了……经过排查，发现是因为在初始化dp数组第一行第一列的时候，i都是从0开始统计的，所以导致了dp[0][0]被重复统计了两次。修改的方法是，初始化第一行时 i 的起始值为0，然后初始化第一列时 i 的起始值为1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//修改前</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columns; i++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][i] = matrix[<span class="number">0</span>][i];</span><br><span class="line">    sum += dp[<span class="number">0</span>][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>];</span><br><span class="line">    sum += dp[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columns; i++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][i] = matrix[<span class="number">0</span>][i];</span><br><span class="line">    sum += dp[<span class="number">0</span>][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; i++)&#123; <span class="comment">//从1开始</span></span><br><span class="line">    dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>];</span><br><span class="line">    sum += dp[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>收获：</strong></p>
<ul>
<li>回顾了二维vector的初始化方式</li>
</ul>
<hr>
<p>2020.05.22<br>451-Sort Characters By Frequency 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　本题的题意很简单，难点在于如何去选择合适的方式处理。最开始想到大顶堆，但是思路里有细节之处未能完善，遂放弃。然后又看了几眼，发现用“哈希链表”就能解决。但是用哈希链表时的一个问题在于，链表排序起来非常麻烦，交换位置的时候还要同改变前后指针，不能用sort，最直接简单的方式就只能是冒泡排序。<br>　　我突然想到：<strong>根本不需要链表，换用vector就行了</strong>。map存储&lt;char, Node<em>&gt;，vector也存储Node</em>，然后直接用<code>sort();</code>对vector元素所指向的Node结点进行排序就好了。代码提交的时候一遍过，说明该思路正确。只不过测试样例的时候遇到了一些错误：</p>
<ul>
<li>用<code>sort();</code>对vector排序类比于对数组排序，所以肯定是写错了</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改前</span></span><br><span class="line"><span class="keyword">int</span> vSize = v.size();</span><br><span class="line">sort(v, v + vSize, cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line">sort(v.begin(), v.end(), cmp);</span><br></pre></td></tr></table></figure>
<ul>
<li>修改sort写法后，又出现了以下报错。经过查找，找到了两篇博文说明了该报错出现的原因：自定义排序cmp函数前应该加一个static</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Line <span class="number">34</span>: Char <span class="number">34</span>: fatal error: reference to non-<span class="keyword">static</span> member function must be called</span><br><span class="line">        sort(v.begin(), v.end(), cmp);</span><br><span class="line">                                 ^~~</span><br><span class="line"></span><br><span class="line">https:<span class="comment">//blog.csdn.net/u010982765/article/details/79021426</span></span><br><span class="line">https:<span class="comment">//blog.csdn.net/qq_26849233/article/details/77930991</span></span><br></pre></td></tr></table></figure>
<p>　　提交后去看评论区，发现有很多人用了之前被我放弃掉的“大顶堆”。看了他们的代码，我才想起来，我放弃是因为我以为堆的每个结点只能存储一种数据，而其他人在堆里存储的是<code>pair&lt;int,char&gt;</code>。其实也无所谓了，在本题，用大顶堆和用sort对vector进行排序的效果是一样的。</p>
<p><strong>收获：</strong></p>
<ul>
<li>回顾了<code>sort();</code>对结构体的<a href="">相关操作</a></li>
<li>学到了关于自定义排序cmp函数未曾注意过的细节：要加static</li>
</ul>
<hr>
<p>2020.05.23<br>986- Interval List Intersections 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　看了看题目，感觉不难。想了一种解法，写出来完整的代码却一运行就报错。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AddressSanitizer:DEADLYSIGNAL</span><br><span class="line">=================================================================</span><br><span class="line">==<span class="number">32</span>==ERROR: AddressSanitizer: <span class="built_in">stack</span>-overflow on address <span class="number">0x7ffe3fdd0668</span> (pc <span class="number">0x000000384a48</span> bp <span class="number">0x7ffe7b77d290</span> sp <span class="number">0x7ffe3fdd0640</span> T0)</span><br><span class="line">    #<span class="number">3</span> <span class="number">0x7ffb7a09a82f</span>  (/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>+<span class="number">0x2082f</span>)</span><br><span class="line">==<span class="number">32</span>==ABORTING</span><br></pre></td></tr></table></figure>
<p>　　然后发现是因为数组<code>bool flag[1000000001];</code>开太大了。数组大小减小1000后就不会报错，但是这样做代码肯定就不能通过所有数据。而且即使减小数组后没有报错，但是输出的结果还是错误的，说明思路是错的，没办法就只好去看题解了。<br>　　但是在看到题解之前突然又有了新想法，于是开始写。写完代码 + debug花了一个多小时，提交过了。记录一下过程中遇到的bug：</p>
<ul>
<li><p>报错ERROR: AddressSanitizer: heap-buffer-overflow on address，因为之前遇到过这个问题，知道是数组越界，就在代码里写了一堆printf查错。最后加了一句，当末端相等时，i j 两个指针同时更新</p>
</li>
<li><p>插入的区间出现了[13, 12]这种逆序的情况。这才发现我在代码里列出的四种if else语句判断的都是两区间有重叠的情况，而没有考虑两区间有间隔的情况。然后又在代码里添加了两种if else判断。此时代码if else共计6种情况</p>
</li>
<li><p>因为if else列出的情况太多，所以部分判断语句弄混了，获得一次TLE提交记录。修改后提交通过。</p>
</li>
</ul>
<p>　　提交后看题解区，官方题解的思路跟我一样，都是用双指针来解题。只不过代码比我简洁太多了，直接用<code>max(); min()</code>来获取小区间左右端点。</p>
<p><strong>收获：</strong></p>
<ul>
<li>今天发现如果在LeetCode里不写for循环的第三段，就会报错TLE，这种情况就要换用while</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; ) &#123;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>2020.05.24</p>
<p>1008-Construct Binary Search Tree from Preorder Traversal 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　在一个月前做过原题，2020.04.20 1008-Construct Binary Search Tree from Preorder Traversal。虽然我一个月前说过，忽略“先序序列”而直接用“二叉搜索树插入结点”的方式做法有“取巧”的感觉，但是今天还是没忍住套模板直接做了。真的不想去看什么分治之类的解法，因为直接插入结点实在太简单了……</p>
<p><strong>收获：</strong></p>
<ul>
<li>回顾了<a href="https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/er-cha-sou-suo-shu-cao-zuo-ji-jin" target="_blank" rel="noopener">二叉搜索树的插入模板</a></li>
</ul>
<hr>
<p>2020.05.25<br>1035-Uncrossed Lines 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　因为是求最大值，我估计应该是个动态规划，但是想了一个小时还是写不出来递推式，就只想出来一个测试样例。唉……就应该按照之前的约定，十分钟想不出来就去看题解的。</p>
<blockquote>
<p>测试样例，不连4，连2、3时取得最大值<br>8 1 2 3 4<br>9 5 6 7 4 2 3</p>
</blockquote>
<p>　　看了评论区才知道，原来本题在本质上与“最长公共子序列”一模一样。题解区也有用“最长非连续上升子序列”的思路，不过这种做法的代码相比于“最长公共子序列”的代码就复杂了一些。由此可见，2020.04.26 1143-Longest Common Subsequence 这道之前写过的题就相当于没做过……</p>
<p><strong>收获：</strong></p>
<ul>
<li>回顾了“<a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-chang-gong-gong-zi-xu-lie" target="_blank" rel="noopener">最长公共子序列</a>”</li>
</ul>
<hr>
<p>2020.05.26<br>525-Contiguous Array 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　2020.04.13 525-Contiguous Array 原题，因为当时这题给我留下的印象太深刻了，今天差不多直接默写出来了，提交一遍过。</p>
<p><strong>收获：</strong></p>
<ul>
<li>今天用了unordered_map，但是发现也仅仅超过了30%，看来本题如果想要大幅度减少运行时间，还是要用数组去做</li>
</ul>
<hr>
<p>2020.05.27<br>525-Possible Bipartition 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　因为以前研究过二分图，所以今天一看标题和题面，就知道这是个二分图判定模板题。自知肯定不能迅速想出完整过程，于是就找到了记录过的一个<a href="https://www.cnblogs.com/digitalhermit/p/5119908.html" target="_blank" rel="noopener">模板</a>，对着模板写了一遍。<strong>本以为对着模板写就能一遍过，谁知道第三次提交才通过</strong>……</p>
<ol>
<li>第一次提交 Wrong Answer，又是对比模板查错，又是写printf输出，耗费了13分钟，才发现是因为有一个for循环的 i 初始化时没有赋值，就仅仅写了个<code>int i;</code>，导致根本就没进入到这个for循环。唉，实在无语，万万没想到到现在还能犯这种低级错误</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改前</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i; i &lt; N; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>第二次提交    Runtime Error，错误信息：Line 12: Char 16: runtime error: index 2000 out of bounds for type ‘int [2000]’ (solution.cpp). 一看到这个错误信息，我就知道是因为数组开小了：比如 N = 2000，如果仅仅定义一个数组 int a[2000]，那么最后一个元素是a[1999]，并不能取到a[2000]。所以一般我定义固定长度的数组时都会默认加5，比如 int a[2005]这样。今天莫名其妙脑子抽了没有加5，就仅仅定义了一个 int a[2000]，最终导致数组越界出错。</li>
</ol>
<p><strong>收获：</strong></p>
<ul>
<li>回顾了二分图</li>
</ul>
<hr>
<p>2020.05.28<br>338-Counting Bits 题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　如果按题意直接暴力做很简单，但是题目额外要求时间复杂度为$O(n)$，就稍微增加了一点难度，不过还是比较简单的。首先我在画板上写了前十个数找规律，就相当于进行“打表”找规律，看着看着就发现了一个简单的dp式：<br>$$<br>dp[i] =<br>\begin{cases}<br>0,  &amp; \text{if $i$ == 0} \<br>1, &amp; \text{if $i$ == 1} \<br>dp[i - k] + 1, &amp; \text{if $i$ &gt;= 2 (k = 2, 4, 8, 16…)}<br>\end{cases}<br>$$</p>
<p>　　这个dp推导式的形式就非常类似于斐波那契数列，前两项是特例，后面的元素的值都由前面元素相关连。这个不断变化的 $k$ 的作用就相当于定义了一个区间，当 2&lt;=i&lt;4 时，dp[i] = dp[i - 2] + 1; 当 4&lt;=i&lt;8 时， dp[i] = dp[i - 4] + 1, 以此类推。<br>　　写完代码测试样例，报错。看样子应该是数组越界，检查了一下代码发现确实是数组越界。因为我定义vector时并没有规定长度，而代码里写的是 <code>dp[i] = dp[i - k] + 1;</code>，使用了一个并不存在的元素dp[i]，应该改为 <code>dp.push_back(dp[i - k] + 1);</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">==<span class="number">33</span>==ERROR: AddressSanitizer: heap-buffer-overflow on address <span class="number">0x602000000038</span> at pc <span class="number">0x000000382d37</span> bp <span class="number">0x7ffe95986df0</span> sp <span class="number">0x7ffe95986de8</span></span><br><span class="line">WRITE of size <span class="number">4</span> at <span class="number">0x602000000038</span> thread T0</span><br></pre></td></tr></table></figure></p>
<p>　　在我准备提交之前，我突然发现代码里漏写了一个细节：就是当输入的数据为0或1时，dp前两个元素每次插入后，就直接返回当前vector，因为dp数组的前两个元素是特例，不符合后面的通用规则，所以就要特殊对待。修改以上两个bug后，提交一遍过。<br>　　之后看了一下题解区，我的思路与官方题解方法二以及<a href="https://leetcode-cn.com/problems/counting-bits/solution/dong-tai-gui-hua-you-xiao-qu-jian-hen-yi-dong-de-d/" target="_blank" rel="noopener">这篇题解</a>基本一致。本题的另一种思路就是利用奇偶性解题，很简单也很巧妙，我应该是想不出来这种解法。</p>
<p><strong>收获：</strong></p>
<ul>
<li>了解了 <a href="https://blog.csdn.net/u010945683/article/details/46757757" target="_blank" rel="noopener">Mathjax “分情况表达式”</a> 的写法</li>
</ul>
<hr>
<p>2020.05.29<br>207-Course Schedule  题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　题目一看就知道是个拓扑排序模板题，然后就直接去题解区看解法了。本题主要分为两种思路：①bfs，用queue + 入度表；②dfs，判断图是否有环。最终我参照<a href="https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/" target="_blank" rel="noopener">这篇题解</a>选取了bfs的思路写了一遍，第一次提交就通过了，只不过在调试的时候遇到了几处报错：</p>
<ul>
<li>报错如下，一开始看到这个 报错感觉很奇怪，不能进行自加操作？查了一会儿也没查到什么，后来反复看了几遍代码，终于发现我又把<strong>初始化vector</strong>的操作写错成<strong>初始化数组</strong>的操作了，就是本来应该写圆括号，写成了方括号了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Line 10: Char 43: fatal error: cannot increment value of type 'vector&lt;int&gt;'</span><br><span class="line">            indegrees[prerequisites[i][<span class="number">0</span>]]++;</span><br><span class="line">            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^</span><br><span class="line"><span class="number">1</span> error generated.</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改前</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegrees[numCourses + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegrees(numCourses + <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>报错显示queue不能用top()这个操作，我正奇怪呢，顺手查了一下，才发现在queue里该操作应该用front()，在stack里才是top()</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Line 24: Char 25: fatal error: no member named 'top' in 'std::queue&lt;int, std::deque&lt;int, std::allocator&lt;int&gt; &gt; &gt;'</span><br><span class="line">            <span class="keyword">int</span> tmp = q.top();</span><br><span class="line">                      ~ ^</span><br><span class="line"><span class="number">1</span> error generated.</span><br></pre></td></tr></table></figure>
<ul>
<li>报错没看懂，去网上查了查，找到<a href="https://blog.csdn.net/sunprice/article/details/82928596" target="_blank" rel="noopener">一篇博文</a>写得很详细，对照了一下，发现我代码中定义了一个二维vector，没有进行任何初始化操作就直接使用了。然后就添加了一句 <code>adjacency.resize(numCourses + 5);</code>就可以了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Line 924: Char 9: runtime error: reference binding to null pointer of type 'std::vector&lt;int, std::allocator&lt;int&gt; &gt;' (stl_vector.h)</span><br><span class="line">SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/<span class="number">8</span>/../../../../include/c++/<span class="number">8</span>/bits/stl_vector.h:<span class="number">933</span>:<span class="number">9</span></span><br></pre></td></tr></table></figure>
<p><strong>收获：</strong></p>
<ul>
<li>学习了如何用bfs判定拓扑序列</li>
<li>大概了解了如何用dfs判定图中是否有环</li>
</ul>
<hr>
<p>2020.05.30<br>973-K Closest Points to Origin  题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　题意简单明了，本来想用大顶堆去做，但是看着看着突然感觉本题最直接的思路和之前做过的 451-Sort Characters By Frequency 基本一致。于是就对照着 451-Sort Characters By Frequency 的代码写了一遍，思路就是进行排序。由于之前已经踩过坑并作记录，所以前人栽树后人乘凉，今天写完提交一遍过了。只不过测试时遇到了一次报错：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Line <span class="number">4</span>: Char <span class="number">25</span>: fatal error: expected parameter declarator</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(<span class="number">2</span>);</span><br><span class="line">                        ^</span><br><span class="line"><span class="number">1</span> error generated.</span><br></pre></td></tr></table></figure>
<p>这个报错让我感到很奇怪，因为按理来讲，这样初始化vector并不会有什么问题。搜了一下，幸好在Stack Overflow上找到了<a href="https://stackoverflow.com/questions/39560277/vector-declaration-expected-parameter-declarator" target="_blank" rel="noopener">一个问题</a>，下面回复的意思大致是“class类中的vector需要在构造函数里进行初始化大小。于是我修改了一下class，bug便解决了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改前</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">double</span> distance = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    Node(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v) &#123;</span><br><span class="line">        tmp = v;</span><br><span class="line">        distance = <span class="built_in">sqrt</span>(tmp[<span class="number">0</span>] * tmp[<span class="number">0</span>] + tmp[<span class="number">1</span>] * tmp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">double</span> distance = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    Node(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v) &#123;</span><br><span class="line">        tmp.resize(<span class="number">2</span>);</span><br><span class="line">        tmp = v;</span><br><span class="line">        distance = <span class="built_in">sqrt</span>(tmp[<span class="number">0</span>] * tmp[<span class="number">0</span>] + tmp[<span class="number">1</span>] * tmp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　提交后看题解区，官方题解有两种，第一种就是排序，第二种用的是分治思想，时间复杂度更低。懒癌发作，分治算法以后再补。</p>
<p><strong>收获：</strong></p>
<ul>
<li>回顾了用sort()对class进行排序</li>
<li>学到了如何在class里正确地初始化vector</li>
</ul>
<hr>
<p>2020.05.31<br>72-Edit Distance   题目顺序类别: May LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　题目看了一遍就自知应该不会做，又思索了一会儿，只能想到因为本题又是一个求最值的问题，所以很可能是用dp去做。果断去看题解，发现本题难度为hard，虽然不会做，但是心里稍微宽慰了一点。<br>　　官方题解思路如我所想，就是用dp去做。不过说实话官方题解的语言比较糟糕，我看了几眼就不想看了……最后还是看<a href="https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-mian-shi-ti-xiang-jie-by-labuladong/" target="_blank" rel="noopener">labuladong的文章</a>才能基本弄懂。照着题解写了一遍，提交一遍过，测试遇到了两个问题：</p>
<ul>
<li>报错heap-buffer-overflow on address，数组越界。反复看了几遍代码，发现是在初始化dp数组的时候，顺序弄反了，应该是先初始化与word1对应的第一列，再初始化与word2对应的第一行，结果写成了word1对应第一行，word2对应第一列了</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改前</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= w1Size; i++) dp[<span class="number">0</span>][i] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= w2Size; i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= w1Size; i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= w2Size; i++) dp[<span class="number">0</span>][i] = i;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试样例的输出结果总是少1。反复看了看代码，突然发现这是一个经常容易写错的点，即word1[i - 1] 对应的是 dp[i] 而不是 dp[i - 1]。这个易错点我曾经在本文2020.04.26 1143-Longest Common Subsequence 记录过，但是今天又忘了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改前</span></span><br><span class="line"><span class="keyword">if</span>(word1[i] == word2[j])</span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    dp[i][j] = min(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line"><span class="keyword">if</span>(word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) <span class="comment">//注意word[i - 1]对应的是dp[i] 而不是 dp[i - 1]</span></span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    dp[i][j] = min(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>　　题外话，今天又突然想起了一个印象很深刻的讲解递归的例子“皇帝问大臣税收，大臣问省长，省长问县长，县长问乡长，乡长问镇长，镇长统计后回复给乡长，乡长回复给县长，县长回复给省长，省长回复给大臣，大臣回复给皇帝”，忘了是在知乎还是哪本书上看到的了。查了一下找到了一个类似的说法：</p>
<blockquote>
<p><a href="https://my.oschina.net/lantianbaiyun/blog/412277" target="_blank" rel="noopener">https://my.oschina.net/lantianbaiyun/blog/412277</a><br>递归好比皇帝让大臣买冰棍，大臣又派小兵去买，小兵买好了送给大臣，大臣再送给皇帝吃。<br>迭代好比皇帝问大臣去哪买冰棍，大臣说你可以问小兵，皇帝又问小兵，小兵说城门杂货铺，于是皇帝去城门杂货铺买了个冰棍。</p>
</blockquote>
<p><strong>收获：</strong></p>
<ul>
<li>学到了一种动态规划题型，以及回顾了字符串dp题的易错点</li>
</ul>
<hr>
<p>2020.06.01<br>226-Invert Binary Tree   题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　翻转二叉树，久闻大名，但今天一看，发现就是个简单的后序遍历二叉树，半分钟不到就写完了，一遍过。</p>
<p><strong>收获：</strong> 无</p>
<hr>
<p>2020.06.02<br>237-Delete Node in a Linked List  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　今天的题有点意思。乍一看题目，就是一个简单的删除链表结点，而且还给了很多限制条件，比如至少有两个结点，每个结点的值都是唯一的等等。正当我准备写的时候，突然发现，输入的参数没有头结点？？？也就是说不能够从头遍历找到被删除结点的前一个结点了。<br>　　然后我想到，那直接把指向当前被删除结点的指针指向下一个结点不就行了，那么前一个结点的next就自动越过该结点了。于是写了一句 <code>node = node -&gt; next;</code>，本以为大功告成，结果测试样例输出错误。随后我又想了想，灵机一动，那我将被删除结点的next指针越过下一个结点，然后复制下一个结点的值到当前结点，不就相当于删除了本结点吗？迅速写了两行代码，提交一遍过。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -&gt; val = node -&gt; next -&gt; val;</span><br><span class="line">node -&gt; next = node -&gt; next -&gt; next;</span><br></pre></td></tr></table></figure>
<p>　　其实提交后我不明白为什么第一种思路不对，过了好久自己才想明白：就好比一个女子的大儿子叫张大，大儿子的弟弟叫张二，如同第一种思路，把大儿子的名字换成了张二，但是女子的大儿子依旧还是原来的那个张大，大儿子的还是有一个弟弟，女子依然有两个儿子不变。第二种思路是，不仅把张大的名字换成张二，而且还通过技术使得张大的外貌和张二一模一样。<br>　　官方题解只有一种，跟我第二种思路一模一样。但是我突然在评论区发现了只有一行代码的题解 <code>*node = *(node -&gt; next);</code>，我感到奇怪，这不就是我第一种思路吗？为什么能通过？然后看了<a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/comments/44027" target="_blank" rel="noopener">评论</a>才明白还是有区别的，<code>*node</code> 代表的是“获取node指针所指向的内容”。</p>
<p><strong>收获：</strong> </p>
<ul>
<li>学到了关于指针的操作</li>
</ul>
<hr>
<p>2020.06.03<br>1029-Two City Scheduling  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　看了看题面，暴力dfs应该能得出结果，但肯定会超时。所以感觉应该是用dp做，然后突然发觉本题好像就是一个“01背包”，就是选或不选的问题。思考了一会儿发现确是是01背包，但尴尬的是，我并不知道01背包具体怎么写，只知道一个大概。<br>　　突然，我想起了在<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie" target="_blank" rel="noopener">labuladong的算法小抄</a>里看到作者解决dp问题首先是写一个dfs暴力搜索，然后根据dfs函数转化成dp代码。遵循这一思路，我就先写了一个dfs函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> numA)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//i表示已经处理了几个人，numA表示去A城的人数</span></span><br><span class="line">    <span class="keyword">if</span>(i == costSize)</span><br><span class="line">        <span class="keyword">if</span>(numA == costSize / <span class="number">2</span>)&#123;</span><br><span class="line">            ans = min(ans, nowCost);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    nowCost += costs[i][<span class="number">0</span>];</span><br><span class="line">    dfs(i + <span class="number">1</span>, numA + <span class="number">1</span>);</span><br><span class="line">    nowCost -= costs[i][<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    nowCost +=cost[i][<span class="number">1</span>];</span><br><span class="line">    dfs(i + <span class="number">1</span>, numA);</span><br><span class="line">    nowCost -= cost[i][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对照着这个dfs函数，我在画板上一边画一个dp表，一边填充数字，尝试着找到一个完善的思路，如何对dp表初始化，如何递推。最终写写画画加上debug一个多小时，终于把代码写出来了。这个dp表跟寻常的dp表相比，稍微有些不同，比如寻常dp表是先初始化第一列第一行，这个dp表是先初始化第一列和对角线。提一次提交 Wrong Answer，用printf把dp表打印出来，才发现是初始化时写错了一个地方，改过后提交成功。不管怎么说，这是由我独自推导写出的一个dp，心里还是很高兴的。<br>　　然后看题解区，让我差异的是中文题解区大部分人采用了一个很特别的贪心法。我在英文讨论区反倒是找到<a href="https://leetcode.com/problems/two-city-scheduling/discuss/278731/Java-DP-Easy-to-Understand" target="_blank" rel="noopener">一篇贴子</a>，与我的思路大致相同，只不过dp元素代表的含义稍有差别。纵然贪心法几行代码就能写完，但说实话，我感觉并这个解法并没有什么普适性，我要是直接想肯定想不出来这个绕弯子的思路，所以它对我来说价值远不如“01背包”的思想。</p>
<p><strong>收获：</strong> </p>
<ul>
<li>实际操作了一次“把dfs函数转化为dp”</li>
</ul>
<hr>
<p>2020.06.04<br>344-Reverse String  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　反转字符串，经典C语言练习题，没啥意思，写了几行提交就过了。看评论区大多数用的都是“双指针”，只有<a href="https://leetcode-cn.com/problems/reverse-string/solution/si-lu-jian-dan-qing-xi-yong-shi-1ms-by-dawei2233/" target="_blank" rel="noopener">一篇题解</a>与我的代码基本一致。我本来以为“双指针”是个什么高端的解法，然后仔细一琢磨，发现跟我的思路基本是一致的，因为我本质上用的也是双指针。只不过别人的指针是<code>i, j</code>，我的是<code>i, sSize - 1 - i</code>；别人的循环终止条件是<code>j &lt; i</code>，我的是<code>i &lt; sSize / 2</code></p>
<p><strong>收获：</strong> 无</p>
<hr>
<p>2020.06.05<br>528-Random Pick with Weight  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　第一次碰到无论英文中文题面都完全没看懂是什么意思……看官方题解说什么前缀和+二分查找，完全没明白与题目有什么关联……然后看评论区，说是题目要求设计一个“带权重的随机算法”，也有人提到了“模拟抽卡游戏”，我联想到炉石的开包，这才渐渐明白本题的意思。但脑袋也比较昏，就直接照着<a href="https://leetcode-cn.com/problems/random-pick-with-weight/comments/236884" target="_blank" rel="noopener">一篇比较短的代码</a>写了一遍就提交了。提交后我还在纳闷，其他题解都用了二分查找，这篇代码为什么没用二分，然后经过搜索才知道代码里的 <code>lower_bound(w_.begin(), w_.end(), i)</code> 实际上就是用二分查找实现的。<br>　　之后又看到<a href="https://leetcode-cn.com/problems/random-pick-with-weight/solution/lun-pan-du-suan-fa-by-joyboy/" target="_blank" rel="noopener">一篇中文解析</a>写得很详细，非常不错，算是把本题的含义讲透了。我最开始有一个疑惑：为什么随机算法能生成固定的答案呢？这篇解析里阐述道，“要求当pickIndex执行次数足够多时，下标i在统计意义上的出现概率满足”，我这就理解了。再去逛英文讨论区，发现<a href="https://leetcode.com/problems/random-pick-with-weight/discuss/671445/Question-explained" target="_blank" rel="noopener">最高票贴子</a>也同样是给大家解释题目含义……看来，即便是英文母语者也看不懂题意哈哈哈<br>　　另外，后来我才发现英文题面没看懂的一个原因是，当我直接看没看懂意思，然后用翻译，翻译把“index”翻译成了“指数、指标”，实际上它在这里应该是“下标、索引”的含义。</p>
<p><strong>收获：</strong> </p>
<ul>
<li>vector二分查找下标内置函数<code>lower_bound(w_.begin(), w_.end(), i)</code></li>
</ul>
<hr>
<p>2020.06.06<br>406-Queue Reconstruction by Height  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　没啥好说的，真的想不出来。最初还挣扎着写了一版代码，输出不对，遂放弃，直接看题解去了。具体做法就是排序+插入，官方题解里写的是“贪心”，不过说实话，我暂时没看出来“贪心”体现在哪里……最后对照着<a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/406-gen-ju-shen-gao-zhong-jian-dui-lie-pai-xu-hou-/" target="_blank" rel="noopener">这篇题解</a>的代码写了一遍。最后对vector进行遍历的时候，我稍微改了一下，就没有用auto关键字了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原始代码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : people) &#123;</span><br><span class="line">    res.insert(res.begin() + e[<span class="number">1</span>], e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改代码</span></span><br><span class="line"><span class="keyword">int</span> pSize = people.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pSize; i++) &#123;</span><br><span class="line">    ans.insert(ans.begin() + people[i][<span class="number">1</span>], people[i]);</span><br><span class="line">    <span class="comment">//在第people[i][1]个元素（从第0个算起）位置插入people[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>收获：</strong> </p>
<ul>
<li>学习了vector中 insert 的<a href="https://blog.csdn.net/weixin_41743247/article/details/90635931" target="_blank" rel="noopener">用法</a></li>
</ul>
<hr>
<p>2020.06.07<br>518-Coin Change 2  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　今天这道题做得整个人脑淤血……初看这道题，想到最暴力的dfs解法，但肯定会超时。然后感觉像是一个完全背包的变形题，但是因为本题所需求的目标(方案数量)与完全背包模板题所求目标(背包最大价值)不一样，所以我就没有去找完全背包的模板了。然后我又觉得本题和经典的dp题目过河卒、斐波那契数列有点像，于是就凭感觉写了一个简单的一维dp，但是结果不对。后来又翻来覆去改了很多遍，结果还是不对……大脑就死机了……<br>　　然后看了官方题解就<strong>更郁闷了</strong>，因为目测它与我写的代码的形式非常像，但我测试第一个样例的输出结果却一直是错的，答案是4输出是9，算多了……</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//官方题解Java代码</span></span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x = coin; x &lt; amount + <span class="number">1</span>; ++x) &#123;</span><br><span class="line">    dp[x] += dp[x - coin];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[amount];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//我的代码</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> coinsSize = coins.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= amount; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coinsSize; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i + coins[j] &lt;= amount)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                dp[i + coins[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i + coins[j]] += dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> dp[amount];</span><br></pre></td></tr></table></figure>
<p>　　直到我看到了<a href="https://leetcode-cn.com/problems/coin-change-2/solution/ling-qian-dui-huan-iihe-pa-lou-ti-wen-ti-dao-di-yo/" target="_blank" rel="noopener">这篇解析</a>我才知道为什么两个代码这么相似，而我却算错了、算多了—— <strong>因为我是在计算排列数，而本题实际上是求组合数。</strong> 以下为摘录：</p>
<blockquote>
<p>但是当你运行之后，却发现这个代码并不正确，得到的结果比预期的大。究其原因，该代码计算的结果是<strong>排列数</strong>，而不是<strong>组合数</strong>，也就是代码会把1,2和2,1当做两种情况。但更加根本的原因是我们子问题定义出现了错误。</p>
</blockquote>
<p>　　之后又仔细看了该解析(注意作者有不少笔误)和其他的一些题解，算是大概弄明白了。</p>
<p><strong>收获：</strong> </p>
<ul>
<li>学习了关于完全背包问题的一些知识点</li>
</ul>
<hr>
<p>2020.06.08<br>231-Power of Two  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　今天的题很简单，判断输入的int是否为2的幂。看到题目脑海中就瞬间想出一种解法：通过一个for循环计算出 2^31-1 内所有2的幂并记录在map中，然后查找输入的n是否在map里，时间复杂度为$O(n)$。提交，通过。<br>　　看了题解区，瞬间傻眼了，因为我发现我的思路是最垃圾的一种…… 另外有两种更好的思路：</p>
<blockquote>
<p>① 不断除2，时间复杂度为$O(log\ n)$ <a href="https://leetcode-cn.com/problems/power-of-two/solution/cyu-yan-jie-fa-by-hua-li-shu-ww-3/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/power-of-two/solution/cyu-yan-jie-fa-by-hua-li-shu-ww-3/</a><br>② 位运算，时间复杂度为$O(1)$ <a href="https://leetcode-cn.com/problems/power-of-two/solution/power-of-two-er-jin-zhi-ji-jian-by-jyd/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/power-of-two/solution/power-of-two-er-jin-zhi-ji-jian-by-jyd/</a></p>
</blockquote>
<p><strong>收获：</strong> </p>
<ul>
<li>学到了一个位运算解题思路</li>
</ul>
<hr>
<p>2020.06.09<br>392-Is Subsequence  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　判断是否为子序列，很简单的一道“双指针”题目。第一遍提交Wrong Answer，这么简单的题实属丢人。仔细查看了一下代码，发现是因为<strong>第一版代码里 j 根据 i 进行变化，而实际上 j 的改变与 i 并没有什么关联</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改前</span></span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; sSize) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = i; <span class="comment">//批注：这句是错的</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; tSize) &#123; <span class="comment">//在主串中寻找</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == t[j]) &#123; <span class="comment">//找到了一个字母</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">1</span>) i++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; sSize) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; tSize) &#123; <span class="comment">//在主串中寻找</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == t[j]) &#123; <span class="comment">//找到了一个字母</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>　　题解区里基本上跟我一样也都是双指针的做法。本题的follow up 暂时还没看，待补。</p>
<p><strong>收获：</strong> </p>
<ul>
<li>复习了双指针</li>
</ul>
<hr>
<p>2020.06.10<br>35-Search Insert Position  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　本题$O(n)$解法一眼就能看出来，无需多言。题干里 “查找 + 已排序数组” 这两个元素组合在一起，立刻就能想到本题的最优解应该是用二分查找。唉，不过说来惭愧，到现在也刷了60多道题了，二分查找还是不能独立写出来……由于本题不是查找一个数组里确定的目标，而是找到一个介于两个数之间的位置，所以就不是最普通的二分查找，而应该采用<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/er-fen-cha-zhao-xiang-jie#er-xun-zhao-zuo-ce-bian-jie-de-er-fen-sou-suo" target="_blank" rel="noopener">寻找左侧边界的二分查找模板</a>。当然本题跟模板有一点区别，我稍作修改了，测试、提交一遍过。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板代码</span></span><br><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">    right = mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line"><span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">    <span class="keyword">return</span> mid == <span class="number">0</span> ? <span class="number">0</span> : mid; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>收获：</strong> </p>
<ul>
<li>复习了寻找左侧边界的二分查找模板](<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/er-fen-cha-zhao-xiang-jie#er-xun-zhao-zuo-ce-bian-jie-de-er-fen-sou-suo" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/er-fen-cha-zhao-xiang-jie#er-xun-zhao-zuo-ce-bian-jie-de-er-fen-sou-suo</a>)</li>
<li>对于二分查找还是不够烂熟于心，有时间一定要研究透彻！！！</li>
</ul>
<hr>
<p>2020.06.11<br>75-  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong>
　　</p>
<p><strong>收获：</strong> </p>
<ul>
<li></li>
</ul>
<hr>
<p>2020.06.12<br>380-  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　<a href="https://blog.csdn.net/littleflypig/article/details/88029469" target="_blank" rel="noopener">c++ STL中常见容器的时间复杂度</a> 记录了map 和 unordered_map的区别</p>
<p><strong>收获：</strong> </p>
<ul>
<li></li>
</ul>
<hr>
<p>2020.06.13<br>368-Largest Divisible Subset  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　今天这道题本来是感觉不会写的，想直接去看题解，最终硬是被我一点点慢慢磨蹭着写出来了，不过也花费了很多时间。<br>　　首先我凭感觉写了第一版代码，提交，Wrong Answer……41个例子，被<a href="https://leetcode.com/submissions/detail/353107743/" target="_blank" rel="noopener">最后一个例子</a>卡住了。正当我打算放弃，准备去看答案的时候，通过观察这个样例预期输出与实际输出，我发现了本题居然有01背包的影子——就是对于某个符合条件的数据，需要抉择是否要将它选入到子集中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">24</span>,<span class="number">48</span>,<span class="number">240</span>,<span class="number">720</span>]</span><br><span class="line">Expected:</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>,<span class="number">384</span>,<span class="number">768</span>]</span><br></pre></td></tr></table></figure>
<p>既然跟01背包有关联，所以我就开始尝试能不能写出一个dfs函数，想把写出来的dfs函数改为dp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == numsSize) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.size() &gt; maxSize) &#123;</span><br><span class="line">            maxSize = tmp.size();</span><br><span class="line">            maxVec = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums[i] % tmp.back() == <span class="number">0</span>) &#123;</span><br><span class="line">        tmp.push_back(nums[j]);</span><br><span class="line">        dfs(i+<span class="number">1</span>);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">        dfs(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> dfs(i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　虽然吧，这个dfs函数确实写出来了，但是我想了很久不知道怎么把它改写成dp……然后又重新想了一会儿，才写出来一个<strong>出发点并不基于这���������������������������������dfs函数</strong>的dp。<br>　　在思考如何把dfs改写为dp的过程中，最重要的一点是，<strong>应该如何记录下“01背包”的选择路径</strong>。想了一会儿，突然，我脑海中一闪，想起了之前学bfs处理最短迷宫路径问题时，有一种变式题要求输出路径的走法，具体解法就是在每一个结构体元素Node里额外开一个数组来记录当前的路径轨迹。想出来这一要点后，思路就豁然开朗，写出了一个还算完整的dp。测试样例通过，测试上一次Wrong Answer的例子通过，正当我满心欢喜地提交时，返回的结果确又是Wrong Answer…没办法，就只能在代��里��加了一��printf查��。��终��现��少��了一个if判断句，debug了20分钟……</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//修改前</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numsSize; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j] % nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            dp[j] -&gt; vecSize = dp[i] -&gt; vecSize + <span class="number">1</span>;</span><br><span class="line">            dp[j] -&gt; vec = dp[i] -&gt; vec;</span><br><span class="line">            dp[j] -&gt; vec.push_back(nums[j]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dp[j] -&gt; vecSize &gt; maxSize) &#123;</span><br><span class="line">                maxSize = dp[j] -&gt; vecSize;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numsSize; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j] % nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] -&gt; vecSize + <span class="number">1</span> &gt; dp[j] -&gt; vecSize)&#123; <span class="comment">//仅在比已存的vec大时，才会更新vec</span></span><br><span class="line">                dp[j] -&gt; vecSize = dp[i] -&gt; vecSize + <span class="number">1</span>;</span><br><span class="line">                dp[j] -&gt; vec = dp[i] -&gt; vec;</span><br><span class="line">                dp[j] -&gt; vec.push_back(nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dp[j] -&gt; vecSize &gt; maxSize) &#123;</span><br><span class="line">                maxSize = dp[j] -&gt; vecSize;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　提交的代码通过后查看题目，发现只有38%的通过率，所以对于自己能独立写出来这道题，还是很高兴的。<a href="https://leetcode-cn.com/problems/largest-divisible-subset/solution/ge-ren-ti-jie-dpcon2-by-leolee/" target="_blank" rel="noopener">一篇题解</a>，记录路径的方法挺独特的，反正我是想不出来这种做法，值得学习。</p>
<p><strong>收获：</strong> </p>
<ul>
<li>回忆起<strong>如何记录选择的路径</strong></li>
</ul>
<hr>
<p>2020.06.14<br>787-Cheapest Flights Within K Stops  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　看了一眼就知道是“带权最短路径问题”，因为是一个经典问题，印象中解法有两种：Dijkstra算法和Floyd算法。所以就不多想了，直奔题解区了。官方题解给出了两种解法：①dp ② Dijkstra。由于Dijkstra步骤有些复杂，所以我就没详细地看它了。<br>　　然后，我本来以为第一种dp的解法就是Floyd算法，因为我记得Floyd算法实质上就是动态规划。然而我在评论区看到了另一种我没见过的算法——Bellman-Ford算法，我<a href="https://blog.csdn.net/yuewenyao/article/details/81023035" target="_blank" rel="noopener">顺手一查</a>，才发现原来官方题解里的dp解法实质上就是Bellman-Ford算法，因为它的时间复杂度是$O(M*N)$，而Floyd算法的时间复杂度是$O(N^3)$。<br>　　虽然Bellman-Ford算法最常见代码使用的是一维空间，但是我还是选择临摹<a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/discuss/115596/c++-8-line-bellman-ford" target="_blank" rel="noopener">一篇题解</a>的评论区里展示出的二维空间的代码，因为我感觉对于初学者来说，二维空间的代码看起来思路会更清晰易懂一些。<br>　　在临摹代码的过程中，<a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/solution/787-java-jian-dan-zhi-jie-dong-tai-gui-hua-by-alex/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/solution/787-java-jian-dan-zhi-jie-dong-tai-gui-hua-by-alex/</a></p>
<p><strong>收获：</strong> </p>
<ul>
<li>学习了<a href="https://blog.csdn.net/weixin_41162823/article/details/81050235" target="_blank" rel="noopener">Bellman-Ford算法</a></li>
<li><a href="https://blog.csdn.net/yuewenyao/article/details/81023035" target="_blank" rel="noopener">最短路径算法对比比较（bellman-ford，dijkstra，spfa，floyd比较）</a></li>
<li><a href="https://blog.csdn.net/jiange_zh/article/details/50198097" target="_blank" rel="noopener">为何程序员喜欢将INF设置为0x3f3f3f3f？</a></li>
<li>关注了一个up主</li>
<li>今天从别人的代码里学到了一种新的初始化二维vector的方式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我常用的初始化方式</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">vec.resize(rows);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columns; i++)</span><br><span class="line">    vec[i].resize(columns);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++)</span><br><span class="line">        vec[i][j] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//别人的方式</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec(rows, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(columns, <span class="number">-1</span>));</span><br></pre></td></tr></table></figure>
<hr>
<p>2020.06.15<br>700-Search in a Binary Search Tree  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　没啥好说的，在此之前也写过不少二叉树了，这种题就是小菜一碟了，全局变量 + dfs。</p>
<p><strong>收获：</strong> 无</p>
<hr>
<p>2020.06.16<br>468-Validate IP Address  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　第一次在LeetCode里见到这种大模拟题。一般来讲，大模拟题的技术含量不高，但是细节要求程度令人发指。我估计我自己认真写的结果就是，提交、对着错误样例添加if语句，然后反复循环提交修改个七八次才能通过。今天暂时没时间，对照一个python正则表达式代码写了一遍提交了。评论区说很多大公司面试都遇到了本题，之后一定补上C++代码。</p>
<p><strong>收获：</strong> 无</p>
<hr>
<p>2020.06.17<br>130-Surrounded Regions  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　第一遍浏览完题目，感觉本题和《挑战程序设计竞赛》第32页、LeetCode 200-Number of Islands 非常相似，用一句话来简单概括就是“寻找被包围的孤岛”。但是再次浏览题干后，发现本题相对于之前的那两题，难度提升了很多：第一，边界上的’O’不能算作孤岛；第二，任何非边界的’O’如果与边界上的’O’相连，那么它同样也不能算作孤岛。<br>　　虽然难度有提升，但是我还是较快地想出了一个思路：寻找图中的非边界’O’，将它变为’X’，然后通过dfs不断搜寻相邻的’O’再修改为’X’。不过此时会出现一个障碍：如果在搜寻相邻’O’的dfs过程中，突然遇到了在边界上的’O’，那么说明之前修改过的’O’还要再修改回去，恢复原样，那么如何进行“恢复之前的修改操作”？<br>　　想了一会儿，想起来我在 2020.06.13 368-Largest Divisible Subset 中创建结构体变量来记录遍历路径的做法，正好可以应用到本题。<strong>只要记录了本次dfs中走过的路径，即使真的遇到了在边界上的’O’，顺着记录的路径“原路返回”就行了</strong>。之后我又思索了一下，发现本题其实不用通过一个个结构体里的vector来记录路径，这样做会占用很多空间。因为某一条所记录的路径在整个过程中，只是在某一次dfs中有用，所以仅仅<strong>用一个stack来记录每次dfs中的路径就行了</strong>。</p>
<p><a href="https://blog.csdn.net/morebread/article/details/7007225" target="_blank" rel="noopener">千万不要对vector之类的容器使用memset</a>所以后来还是乖乖用二重for循环对二维vector进行初始化</p>
<p><strong>收获：</strong> 无</p>
<hr>
<p>2020.06.18<br>275-H-Index II  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　说实话，这道题我应该是写不出来的，因为一开始就被题目给出的 “H-Index” 的定义给弄晕了，无论是中、英文题目，题干里什么“至少”、“不多于”等等绕来绕去实在是迷糊了。然后我就顺手去看英文题目里给出的索引 <a href="https://en.wikipedia.org/wiki/H-index" target="_blank" rel="noopener">H-Index on Wikipedia</a>，想通过维基百科里的内容来理解 H-Index 的定义。<br>　　首先我就发现了一个差异：维基百科里计算 H-Index 时，输入序列是递减的，而本题的输入序列是递增的。不过，即使看完了维基百科里的定义和给出的示例，我对如何计算出 H-Index 还是没有任何清晰的思路。直到，我突然发现并理解了维基百科里给出的一个公式后，终于学会了计算H-Index的具体步骤：$$h-index(f) = \max \limits_{i} min(f(i),i)$$ </p>
<blockquote>
<p>1.对输入序列进行递减排序<br>2.$f(i)$ 代表每篇paper的引用量，$i$ 代表这篇paper在递减排序中的下标index<br>例如：10、8、5、4、3 中，8排在第二位，它的下标 $i$ 值为2<br>3.对每一篇paper，取引用量 $f(i)$ 和下标 $i$ 的最小值 $min(f(i),i)$<br>4.对所有已经计算出的 $min(f(i),i)$，再取它们的最大值 </p>
</blockquote>
<p>　　其实按照这几个步骤，很快就能写出来一个$O(n)$的算法。但由于本题已经给出了“<strong>已排序序列 + 对数时间复杂度</strong>” 这两个明显的信号，说明本题最优做法应该采用二分查找。唉，如果题目没有这些提示，我是真的想不出来要用到二分查找。<br>　　然后我就参照着本题给的样例和<a href="https://en.wikipedia.org/wiki/H-index" target="_blank" rel="noopener">H-Index on Wikipedia</a>上面举例出的样例，以及维基百科上的一句“we look for the last position in which f is greater than or equal to the position”，马马虎虎地写了一个二分查找，测试了几个样例都通过了。不过，第一次提交被“输入为空序列”卡了，修改代码后第二次提交顺利通过。<strong>额外注意一点</strong>，本题给出的是递增序列，但计算H-Index需要的是递减序列。不过，完全不需要重新进行递减排序，重新排序会增加运行时长，只需在处理过程中计算出某篇paper在递减序列中的排序即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> position = citationsSize - mid; <span class="comment">// 递减排序的第几位</span></span><br><span class="line">    <span class="keyword">int</span> tmp = min(citations[mid], position);<span class="comment">// 取最小值</span></span><br><span class="line">    ans = max(ans, tmp); <span class="comment">//取最大值</span></span><br><span class="line">    <span class="keyword">if</span>(tmp &lt; citations[mid])</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　顺便一提，本题是 274-H-Index 的进阶版。两者的区别在于，前者的输入是一个打乱的序列，而本题的输入是一个已排序好的序列，并且要求对数时间复杂度。</p>
<p><strong>收获：</strong> </p>
<ul>
<li>查了很久，终于在<a href="http://devgou.com/article/MathJax/" target="_blank" rel="noopener">一篇博文</a>找到<strong>如何把Mathjax下标放到正下方</strong></li>
<li>学会了如何计算H-Index</li>
</ul>
<hr>
<p>2020.06.19<br>1044-Longest Duplicate Substring  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　好久都没有出现过这种感觉了——就是看到一道题后没有任何思路，一脸懵逼……因为是子串问题，所以想到了可能会使用到“滑动窗口”，看了一分钟后看不出来本题和“滑动窗口”之间的联系。点开题目下方的提示，第一条提到了二分查找，第二条提到了Rabin-Karp ‘s algorithm…… “子串问题和二分查找还能组合在一起？？？二分查找跟本题有什么关联吗？？？Rabin-Karp ‘s algorithm又是啥？？？” 看完提示后更懵了，所以只能直奔题解区，然后发现本题的难度是 <strong>hard</strong>……行吧，认了。<br>　　看到题解里也的确用到了“滑动窗口”，证明我之前的猜测是对的，可惜虽然“嗅觉”灵敏找出了解题方向，但是技术太差依旧想不出来解法。本题的中文官方题解居然写得还不错，于是就对着官方题解的java代码和另一篇题解的C++代码，综合二者写了一遍。测试样例通过了，但是第一次提交 Wrong Answer。<br>　　看到这个结果，我迅速回忆起，我在把官方题解的Java代码转换为C++代码的过程中，遇到了一个库函数<code>substring()</code>，很明显它的作用就是“取子串”。我想都没想就直接用C++里的<code>substr()</code>去代替。虽然我在替换的过程中闪过一丝念头: “<strong>会不会由于Java和C++的差异，导致这两个函数也会有区别而不能够直接替换呢？</strong>”，<strong>但由于我当时太懒了</strong>，不想分别去查阅这两个函数的具体用法，就直接提交了。<br>　　那么，是不是在这个被我刻意略过的地方出了问题呢？我又重新去查阅了这两个函数的用法，发现问题确实出现在这里，因为这两者确实不能够直接替换：</p>
<blockquote>
<p><a href="https://www.runoob.com/java/java-string-substring.html" target="_blank" rel="noopener">Java substring() 方法</a>的两个参数是：<br>beginIndex – 起始索引（包括）, 索引从 0 开始<br>endIndex – 结束索引</p>
<p><a href="https://blog.csdn.net/liuweiyuxiang/article/details/83687868" target="_blank" rel="noopener">C++中substr函数的用法</a>的两个参数是：<br>pos – 开始位置<br>n – 获取子串的长度</p>
</blockquote>
<p>　　不过后来我看到了一篇博文 <a href="https://blog.csdn.net/monk1992/article/details/81702763?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-3" target="_blank" rel="noopener">C++之substr与substring浅谈</a>，这才知道，原来C++本来就涵盖了这两个库函数。所以<code>substr()</code>和<code>substring()</code> <strong>并不是</strong> 同一种函数在C++和Java里的不同表现形式，它们本质上就不一样……然后修改了我代码里<code>substr()</code>的第二个参数，成功提交。提交后再回看本题，我发现这道hard题的可怕之处主要有两点：</p>
<ol>
<li>本题用到了二分查找，但是题面上<strong>根本没有展现出</strong> “已排序序列、查找、对数时间复杂度” 这三个平常用于判断是否可能会用到二分查找法的标志。</li>
<li>本题用到了滑动窗口，但是官方题解代码里涉及到“滑动窗口”部分的代码，与<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hua-dong-chuang-kou-ji-qiao-jin-jie" target="_blank" rel="noopener">常见的滑动窗口代码模板</a>基本没有什么很高的重合度，也就是说本题很难直接去套模板。</li>
</ol>
<p>　　另外，还有一种解法是用到了“后缀数组/后缀自动机”，代码太长了，就没看了，有时间再补。</p>
<p><strong>收获：</strong></p>
<ul>
<li>官方题解评论区关于“模数”取值大小的一个<a href="https://leetcode-cn.com/problems/longest-duplicate-substring/solution/zui-chang-zhong-fu-zi-chuan-by-leetcode/300716" target="_blank" rel="noopener">讨论</a></li>
</ul>
<hr>
<p>2020.06.20<br>60-Permutation Sequence  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　全排列变式问题，现在对我来说自然就不在话下。因为全排列问题是我大一C语言实验课在OJ上唯一一道写不出来的题目，过了很久，当我理解了“马走日”问题后，才理解全排列问题的解法，所以我估计我这辈子都忘不了全排列问题了……<br>　　题目要求输出第k个全排列，那么最直接的想法就是dfs枚举出所有的全排列并记录下来，然后输出第k个。我还特意计算了一下<strong>9!=362800</strong>，目测30万的数据量dfs应该不会超时，就放心地用这个暴力解法了。而且，虽然这个方法略粗暴无脑，但我很快就想到一个<strong>剪枝</strong>的方法：计算出第k个排列后，就终止dfs，不用再计算出后续的排列了。<br>　　代码很快就写完了，但是在测试样例时却出现了一个报错：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Line <span class="number">6</span>: Char <span class="number">22</span>: fatal error: expected parameter declarator</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; flag(<span class="number">9</span> + <span class="number">1</span>);</span><br><span class="line">                     ^</span><br><span class="line"><span class="number">1</span> error generated.</span><br></pre></td></tr></table></figure>
<p>搜了一下报错信息，在StackOverflow上找到了<a href="https://stackoverflow.com/questions/39560277/vector-declaration-expected-parameter-declarator" target="_blank" rel="noopener">一个相同的问题</a>，我一看，这个页面怎么这么熟悉？然后想起来了，在 2020.05.30 973-K Closest Points to Origin 遇到过一模一样的报错。好吧，明白是什么原因了。本题不必须要用vector，所以我就把代码里 <code>vector&lt;int&gt; flag(9 + 1);</code> 改成了 <code>int flag[9 + 1];</code>。</p>
<p>　　提交通过，但是发现运行时间只击败了28%其他代码。由此我就知道我这种暴力dfs即使进行了剪枝操作，依旧不是本题的最优解。去题解区看，知道了本题最优解是用到了<a href="https://leetcode-cn.com/problems/permutation-sequence/solution/ni-kang-tuo-zhan-kai-xiang-jie-by-boille/" target="_blank" rel="noopener">逆康托展开</a>，懒癌发作以后再补。</p>
<p><strong>收获：</strong></p>
<ul>
<li>回顾了全排列dfs解法</li>
<li>逆康托展开，待补</li>
<li>新学了 str.resize() 操作，参考文章：<a href="https://blog.csdn.net/qq_42659468/article/details/90381985" target="_blank" rel="noopener">C++——String类超详细介绍</a></li>
</ul>
<hr>
<p>2020.06.21<br>174-Dungeon Game 题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　唉，又是不自量力、不撞南墙不回头的一天。僵持了十几个小时还是没能写出来正确的代码，最后依旧是去看题解。<br><a href="https://leetcode.com/submissions/detail/356503882/" target="_blank" rel="noopener">Time Limit Exceeded(点击查看dfs代码)</a>，45组数据通过了41组，证明我的dfs+剪枝的思路还是可以的，可惜性能还是不够，主要还是因为题面没有表明数据量，如果我看到了数据范围可能就不会选择用dfs去做了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Line 924: Char 9: runtime error: reference binding to null pointer of type 'Solution::Node *' (stl_vector.h)</span><br><span class="line">SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/<span class="number">8</span>/../../../../include/c++/<span class="number">8</span>/bits/stl_vector.h:<span class="number">933</span>:<span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>2020.05.31 72-Edit Distance 犯过同样的错</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>,<span class="number">-3</span>,<span class="number">3</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">-2</span>,<span class="number">0</span>],</span><br><span class="line">[<span class="number">-3</span>,<span class="number">-3</span>,<span class="number">-3</span>]]</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>,<span class="number">0</span>)	(<span class="number">-2</span>,<span class="number">-2</span>)	(<span class="number">1</span>,<span class="number">-2</span>)	</span><br><span class="line">(<span class="number">1</span>,<span class="number">0</span>)	(<span class="number">-1</span>,<span class="number">-1</span>)	(<span class="number">-1</span>,<span class="number">-1</span>)	</span><br><span class="line">(<span class="number">-2</span>,<span class="number">-2</span>)	(<span class="number">-4</span>,<span class="number">-4</span>)	(<span class="number">-4</span>,<span class="number">-4</span>)</span><br></pre></td></tr></table></figure>
<p><strong>收获：</strong></p>
<ul>
<li><a href="https://zhidao.baidu.com/question/54898833.html" target="_blank" rel="noopener">在C语言中INT怎么表示无穷大（小）？</a></li>
</ul>
<hr>
<p>2020.06.22<br>174-Single Number II 题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　本题是 136-Single Number 的进阶版变式题，用 Map 就能轻松过，但是这样需要用到额外的 $O(N)$ 空间。然而，题目要求“不使用额外空间”，即空间复杂度为 $O(1)$ ，所以直接用 Map 的做法肯定不是面试官想得到的答案。<br>　　由于 136-Single Number 的最优解是采用“异或”进行位运算，所以我知道本题的最优解很可能也是位运算。可惜太菜了，拿着“异或”对着输入数组比划了半天都没想出来解法，就只能又灰溜溜地跑去题解区看答案了。<br>　　官方题解写得不怎么样，位运算的解法感觉就是对着代码直接解释了一遍，给人的感觉就是“哦，我要这么做”，但是没有说明“我为什么要这么做？”，看完后还是一头雾水。比如文中写道“为了区分出现一次的数字和出现三次的数字，使用两个位掩码：seen_once 和 seen_twice”，我就在想“从何处想到用两个位掩码？”</p>
<p><a href="https://leetcode-cn.com/problems/single-number-ii/solution/zhi-chu-xian-yi-ci-de-shu-zi-ii-shu-zi-dian-lu-she/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/single-number-ii/solution/zhi-chu-xian-yi-ci-de-shu-zi-ii-shu-zi-dian-lu-she/</a><br>讲得非常好，从数字电路（即数字逻辑）的角度出发，提出“三进制加法”。因为三进制的结果是两位的，所以要用到两个bit来表示，完全解决了我上文中提出的困惑。文章然后再由卡诺图推导出逻辑运算表达式，思路非常清晰、精彩。</p>
<p><strong>收获：</strong></p>
<ul>
<li>回顾了数字逻辑的一些知识</li>
</ul>
<hr>
<p>2020.06.23<br>222-Count Complete Tree Nodes 题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　题目很简单，因为我想不出来更好的方法，所以就直接暴力dfs + 全局变量写了一遍。提交居然一次就通过了，只不过运行时间有些长。去看官方题解，才知道本题最优解竟然是二分查找，完全没想过二分查找能和二叉树结合到一起。而且本题又是一个没有“二分查找要素”(已排序序列，要求$O(log\ n)$, 查找) 的题目。</p>
<p><strong>收获：</strong></p>
<ul>
<li><hr>
</li>
</ul>
<p>2020.06.24<br>96-Unique Binary Search Trees 题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　刚看到这道题，感觉暴力dfs列出所有情况应该能算出答案，但是题目又没给数据范围，所以我估计又要超时，就不想往这个方向继续思考了。想了一会儿，感觉本题很可能用一个公式就可以直接算出来，不过我知道自己肯定想不出来这个公式，很快就放弃挣扎直接去看题解。<br>　　官方题解第一种解法是动态规划，这让我很意外，之前完全没想到这一点，因为这是我第一次接触到二叉树与DP相结合的题目。第二种解法跟我之前所想的思路一致，就是用数学公式算出答案。只不过我在看代码的时候，疑惑一点：<strong>为什么代码里还要用for循环逐渐算出答案，而不是用一行代码直接得到结果呢</strong>？后来我了解到，解法二所用到的<a href="https://baike.baidu.com/item/catalan/7605685?fr=aladdin" target="_blank" rel="noopener">卡塔兰数</a>，本质上是“常在各种计数问题中出现的<strong>数列</strong>”，但是这个数列貌似只有<strong>递推公式</strong>而没有<strong>通项公式</strong>，所以只能通过递推公式一步步算出第N项，因此无法通过一行公式直接算出答案，只能利用for循环求解。<br>　　官方题解写得不错，对着题解一的代码写了一遍，提交通过。题解二涉及到卡特兰数，暂时不想看，以后有机会再补。</p>
<p><strong>收获：</strong></p>
<ul>
<li></li>
</ul>
<hr>
<p>2020.06.25<br>287-Find the Duplicate Number 题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　这道题本来很简单，但由于题目附加的多种限制条件，使得本题很多容易想到的思路都被拦腰砍断了。</p>
<ol>
<li><p>数组只能读取不能修改，没有办法进行排序，本来排序后重复的元素相邻，就非常容易找到了。我还想过本题能否用二分查找求解，但还是因为不能进行排序，所以我也就放弃了向二分查找方向继续探寻。</p>
</li>
<li><p>空间复杂度要求为$O(1)$，导致无法使用map</p>
</li>
<li><p>时间复杂度要求小于$O(n^2)$，就不能使用最简单粗暴的双重for循环了</p>
</li>
<li><p>一个重复的数，重复出现的次数可能超过一次，所以我感觉本题也很难用位运算去做</p>
</li>
</ol>
<p>　　由于思考方向全方位受阻，就只能去看题解了。一看官方题解，题解一二分查找，题解二位运算，直接啪啪打脸了上文的第一条和第四条……唉……</p>
<p><strong>收获：</strong></p>
<ul>
<li><hr>
</li>
</ul>
<p>2020.06.26<br>129-Sum Root to Leaf Numbers  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　总算遇到了一道会写的题，大概几分钟就写好了<br><a href="https://blog.csdn.net/wyll19980812/article/details/105441420" target="_blank" rel="noopener">https://blog.csdn.net/wyll19980812/article/details/105441420</a></p>
<p>逆序<br>正序<br>i–</p>
<p><strong>收获：</strong></p>
<ul>
<li><hr>
2020.06.27<br>279-Perfect Squares  题目顺序类别: June LeetCoding Challenge</li>
</ul>
<p><strong>随记：</strong><br>　　感觉有点像是背包问题，所以估计大概率本题是用DP去解决。想了一会儿想不出来完整的思路，就去看题解了。官方题解</p>
<p><strong>收获：</strong></p>
<ul>
<li><hr>
</li>
</ul>
<p>2020.06.28<br>332-Reconstruct Itinerary  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　本来以为就是个普通的模拟题，修修改改写好了第一版代码过了两个样例，提交结果Wrong Answer。看了看反馈的样例，发现题目比我想的要复杂很多，就直接去看题解了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name = <span class="string">""</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt; next;</span><br><span class="line">    </span><br><span class="line">    Node(<span class="built_in">string</span> s, Node* n) &#123;</span><br><span class="line">        name = s;</span><br><span class="line">        <span class="keyword">if</span>(n != <span class="literal">NULL</span>)</span><br><span class="line">            next.push_back(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>收获：</strong></p>
<ul>
<li><hr>
</li>
</ul>
<p>2020.06.29<br>332-Unique Paths  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　经典dp问题——过河卒，没什么好说的。</p>
<p><strong>收获：</strong> 无</p>
<hr>
<p>2020.06.30<br>212-Word Search II  题目顺序类别: June LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　本题本来是直接准备dfs的，但是隐约感觉可能会超时，就犹豫着要不要直接写。突然看到题目下方有提示，点开看了一下，说是要用字典树去做，我这才恍然大悟。之前因为输入的样例给的是一个二维矩阵的形式，所以我从来没有往字典树方向去思考过。虽然写过字典树的模板题 402-Implement Trie (Prefix Tree)，但是现在也忘记七七八八了，还得对着当时写的代码去解决本题，唉……<br>　　不过我在创建字典树时，突然有了疑惑，因为感觉这个把二维矩阵创建成字典树，然后把word列表输入字典树查询的过程，好像跟直接dfs也差不多？而且，生成的字典树依旧会非常非常庞大，并且创建后再查询，貌似许耗时貌似还会更长？<br>　　过了一会儿，我突然又恍然大悟：之前陷入了固定思维，本题不是要把二维矩阵变成字典树，然后对word列表的每个string依次进行查询是否存在；而是要把word列表创建成一个字典树，这样一来字典树就会小很多很多，然后将二维矩阵的元素输入到字典树中。</p>
<p>dfs 参数顺序写错，参数值写错</p>
<p>没有进行查重</p>
<p>没有写visited数组</p>
<p>一定要先判断越界，再判断是否visited</p>
<p>一定要记得对visited数组进行resize操作，很多次忘记了，就直接进行初始化赋值，然后就报错，这已经是三四次出现这样的错误了</p>
<p><strong>收获：</strong></p>
<ul>
<li>回顾了字典树 402-Implement Trie (Prefix Tree)。今天磕磕绊绊的我，还在惊讶于当时的自己如何流畅并独立地一遍写完这道字典树模板题的……</li>
</ul>
<hr>
<p>2020.07.01<br>441-Arranging Coins  题目顺序类别: July LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　难得一见的简单题，很快就写完了，一个for循环，时间复杂度为$O(N)$。<br>　　不过后来看了看题解区，了解到本题还有两种更快的解法：二分查找、数学公式法，可参见<a href="https://leetcode.com/articles/arranging-coins/" target="_blank" rel="noopener">英文官方题解</a>。该英文官方题解的评论区第一条对二分查找的解法大加称赞，并且值得注意的是，这条评论下的回复表示“如果我是一个面试官，我更期待得到的解法是二分查找”，可见本题二分查找的解法还是非常重要的，以后有时间再补。</p>
<p><strong>收获：</strong> </p>
<ul>
<li>又遇到一个二分查找的新题型</li>
</ul>
<hr>
<p>2020.07.02<br>107-Binary Tree Level Order Traversal II  题目顺序类别: July LeetCoding Challenge</p>
<p><strong>随记：</strong>
　　</p>
<p><strong>收获：</strong> </p>
<ul>
<li></li>
</ul>
<hr>
<p>2020.07.03<br>957-Prison Cells After N Days  题目顺序类别: July LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　题目乍一看，就是一道简单粗暴的模拟题，于是动手开始写，写的过程中突然发现数据规模最大$10^9$，瞬间倒吸了一口凉气，停顿了一会儿没想出来有什么更好的方法，就只好硬着头皮继续写完。测试了一个样例通过后就提交了，果然 Time Limit Exceeded，超时。更令我无语的是，看了返回的数据，发现是题目的第二个样例，我提交代码前没注意到它，就没有测试第二个样例。如果测试了第二个样例后发现超时，我就肯定不会提交代码了。唉，又白白地降低了自己的提交通过率……<br>　　提交失败后，我又重新审视本题。突然，我有个直觉，感觉到本题很可能是有规律的！于是我就打表找规律，输出一堆代码运行过程中的产生的结果，居然真的发现本题确实是有规律的：输出的结果每14天一循环，即第1天和第15天的结果是一样的！按照发现的规律重新写代码，测试两个样例通过，提交代码通过！<br>　　看了看题解区，思路基本也都差不多。</p>
<p><strong>收获：</strong> 无</p>
<hr>
<p>2020.07.04<br>264-Ugly Number II  题目顺序类别: July LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　题目不难，但是解题的过程磕磕绊绊，并没有我预想中的那么顺利。刚看到本题，我脑海里立刻浮现了一种“找素数”的基本做法：素数筛（可参考<a href="https://baike.baidu.com/item/%E7%AD%9B%E6%B3%95%E6%B1%82%E7%B4%A0%E6%95%B0/8670409?fr=aladdin" target="_blank" rel="noopener">筛法求素数</a>、<a href="https://blog.csdn.net/dy416524/article/details/86431057" target="_blank" rel="noopener">埃氏筛和欧拉筛</a>）。类比于素数筛</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        ans.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ansSize = ans.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; ansSize &lt; n * <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]);</span><br><span class="line">            ans.push_back(ans[i] * <span class="number">2</span>);</span><br><span class="line">            ans.push_back(ans[i] * <span class="number">3</span>);</span><br><span class="line">            ans.push_back(ans[i] * <span class="number">5</span>);</span><br><span class="line">            ansSize += <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ans.begin(), ans.end());</span><br><span class="line">        <span class="keyword">return</span> ans[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>收获：</strong> 无</p>
<hr>
<p>2020.07.05<br>461-Hamming Distance  题目顺序类别: July LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　因为之前也做过几道位运算的题目了，所以本题很快就有思路了。就是将两个数不断向右移位，再进行计数得出答案。类似于 201. Bitwise AND of Numbers Range 的做法，当然，相比而言本题简单太多了。</p>
<p><strong>收获：</strong> 无</p>
<hr>
<p>2020.07.06<br>66-Plus One  题目顺序类别: July LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　很简单，没什么好说的，我看到题目立刻想到的做法就是大整数加法，直接在数组上进行操作就行，而且只是简单地加1而已，稍微注意一下进位问题。第二种做法就是把数组先转化成int加1，然后再转换回数组。</p>
<p><strong>收获：</strong> 无</p>
<hr>
<p>2020.07.07<br>463-Island Perimeter  题目顺序类别: July LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　简单的岛屿问题，没什么价值。本来想写dfs的，然后稍微看了一下发现根本不需要dfs，直接一个二重for循环遍历完地图就行，只不过耗时会多一些。计数某一个“1方格”的周围有 x 个其他的“1方格”，则该方格的周长就是 (4 - x)，累加即可得到整个岛屿的周长。</p>
<p><strong>收获：</strong> 无</p>
<hr>
<p>2020.07.08<br>-3Sum  题目顺序类别: July LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　<br>面向样例编程<br>Compile Error<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Line 7: Char 36: fatal error: call to implicitly-deleted default constructor of 'unordered_set&lt;vector&lt;int&gt; &gt;'</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; s3;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://blog.csdn.net/dreamiond/article/details/88553332?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">C++——unordered_set默认无法哈希vector</a><br>文中讲述的方法很复杂，我在想，unordered_set 不行，那么直接用set可以吗？试了一下，果然可以</p>
<p><strong>收获：</strong> 无</p>
<hr>
<p>2020.07.09<br>662-Maximum Width of Binary Tree  题目顺序类别: July LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　磨蹭了好久，思考过dfs，思考过bfs层次遍历，还是想不出来一个完整的思路，最后还是灰溜溜地去看答案了。为了不值一提的自尊心，又白白浪费了好多时间……<br>　　看了<a href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/solution/ceng-ci-bian-li-shi-xian-by-aaron_yu/" target="_blank" rel="noopener">题解</a>，发现与自己想过的bfs层次遍历的思路基本一致，只不过有一个关键点我做错了：我当时想的是左子树结点为 <code>i-1</code>，右子树下标为 <code>i+1</code> ，验证了几个样例发现不对就放弃了；题解里，左子树结点为 <code>2*i</code>，右子树下标为 <code>2*i+1</code>。唉，真的就只差这关键的一点……只能说基础知识不牢固，因为左结点 <code>2*i</code> 右结点  <code>2*i+1</code> 是学数据结构时一个很基础的知识点。<br>　　既然明白了出错的位置，我就顺着自己之前的思路，修改了代码里最关键的一点，完整地写了一遍。测试了样例都通过了，然而，提交结果 <a href="https://leetcode.com/submissions/detail/364572003/" target="_blank" rel="noopener">Runtime Error</a>，卡在倒数第二组数据，提示“有符号整数溢出”。<br>　　我仔细看了看，发现是因为二叉树结点 val 定义的类型是int，然后在计算过程中的数据会溢出。不得不说，这组数据是真的无聊，非要用“数据类型范围”这一点来卡人…… <a href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/comments/460692" target="_blank" rel="noopener">评论区</a>同样也对这一点怨声载道。<br>　　如果二叉树结点的数据类型能够修改的话，把 val 的类型由 int 修改为 unsigned long long 就行，可惜这是 LeetCode 而不是 ACM 题，所以没办法对预定义好的结点进行修改。所以就只能对于每一个二叉树结点，<strong>需要额外设置一个 unsigned long long 变量来存储 index，然后将这个变量和二叉树结点捆绑到一起</strong>。按照我习惯的做法，应该是创建一个新的class，来将两个数据类型捆绑，但是我看了很多的题解采用了 pair，于是我也采用 pair 重新将代码写了一遍，测试通过，提交通过。</p>
<p><strong>收获：</strong> </p>
<ul>
<li>今天知道了国内外对于“满二叉树”定义是有差别的 <a href="https://blog.csdn.net/threadrunner/article/details/8739847" target="_blank" rel="noopener">full binary tree != 满二叉树</a></li>
<li>复习了pair的相关操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建并插入</span></span><br></pre></td></tr></table></figure>
<hr>
<p>2020.07.10<br>430-Flatten a Multilevel Doubly Linked List  题目顺序类别: July LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　乍一看题目感觉有点复杂，但当我试着写一写的时候，发现比看着要简单很多。<br>　　首先，看到题目这个形式就能立刻想到要用到递归。什么叫“这个形式”，我总结为“<strong>处理当前逻辑层面并且还未处理完时，中途就需要进入到下一个相似的逻辑层面，并且子逻辑层面处理完后还需回到上一个逻辑层面继续</strong>”，比如括号系列问题就是这样的。<br>　　既然明确了“递归”这个大方向，我就开始着手写代码了，第一版代码很快就完整地写出来了。当然也并不会很顺利，在测试样例的时候，报错 Runtime Error，错误信息如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Line 20: Char 34: runtime error: member access within null pointer of type 'Node' (solution.cpp)</span><br><span class="line">SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:<span class="number">72</span>:<span class="number">34</span></span><br></pre></td></tr></table></figure>
<p>　　这个报错信息以前遇到过，就是“进行了空指针的成员访问”。这是什么意思？简单来说，就是不仅遍历到了空指针，并且还要访问空指针的内容，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node* temp = <span class="literal">NULL</span>; <span class="comment">//此时不会出问题，因为只是到达了空指针</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; temp -&gt; val &lt;&lt;<span class="built_in">endl</span>; <span class="comment">//会RE，因为访问了“空指针的内容”</span></span><br></pre></td></tr></table></figure>
<p>　　想要解决这个问题，就要<strong>找到代码里何处“访问了空指针的成员”</strong>。经过我观察，发现了 <code>parent -&gt; next -&gt; prev = temp;</code> 这句代码很有可能造成RE，因为当parent是尾结点的时候，parent -&gt; next 就是 NULL，那么 parent -&gt; next -&gt; prev 就会出现“访问了空指针的成员”这个问题，所以我添加了【一号点】处的if判断句。<br>　　但是，即便添加了【一号点】处的if判断句，测试样例的结果还是RE，就很奇怪。然后我就写了一个printf语句，把遍历的过程打印了出来。打印的结果显示，代码正常地走完了预想的路线，在最后一个结点处RE了，这就更奇怪了。我又观察了一会儿，想起来本题的第一层链表是没有parent结点的，所以我又在【二号点】的if判断句里加上了 <code>&amp;&amp; parent != NULL</code> 来判断是否有parent结点。然后再次测试样例，通过。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一版代码片段</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node* head, Node* parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Node* temp = head; temp != <span class="literal">NULL</span>; temp = temp -&gt; next) &#123;</span><br><span class="line">        <span class="comment">//printf("%d\n",temp -&gt; val);</span></span><br><span class="line">        <span class="keyword">if</span>(temp -&gt; child == <span class="literal">NULL</span>) &#123; <span class="comment">//如果没有孩子结点</span></span><br><span class="line">            <span class="keyword">if</span>(temp -&gt; next == <span class="literal">NULL</span> ) &#123; <span class="comment">//如果是最后一个结点</span></span><br><span class="line">                <span class="comment">//处理尾结点</span></span><br><span class="line">                parent -&gt; next -&gt; prev = temp;</span><br><span class="line">                temp -&gt; next = parent -&gt; next;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//处理首结点</span></span><br><span class="line">                head -&gt; prev = parent;</span><br><span class="line">                parent -&gt; next = head;</span><br><span class="line">                </span><br><span class="line">                parent -&gt; child = <span class="literal">NULL</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dfs(temp -&gt; child, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//提交成功代码片段</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node* head, Node* parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Node* temp = head; temp != <span class="literal">NULL</span>; temp = temp -&gt; next) &#123;</span><br><span class="line">        <span class="comment">//printf("%d\n",temp -&gt; val);</span></span><br><span class="line">        <span class="keyword">if</span>(temp -&gt; child == <span class="literal">NULL</span>) &#123; <span class="comment">//如果没有孩子结点</span></span><br><span class="line">            <span class="keyword">if</span>(temp -&gt; next == <span class="literal">NULL</span> &amp;&amp; parent != <span class="literal">NULL</span>) &#123; <span class="comment">//如果是最后一个结点，并且当前链表有父结点 【二号点】</span></span><br><span class="line">                <span class="comment">//处理尾结点</span></span><br><span class="line">                <span class="keyword">if</span>(parent -&gt; next != <span class="literal">NULL</span>) <span class="comment">//如果不写这个if，会访问到NULL指针的内容，造成RE 【一号点】</span></span><br><span class="line">                    parent -&gt; next -&gt; prev = temp;</span><br><span class="line">                temp -&gt; next = parent -&gt; next;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//处理首结点</span></span><br><span class="line">                head -&gt; prev = parent;</span><br><span class="line">                parent -&gt; next = head;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//记得取消child指针</span></span><br><span class="line">                parent -&gt; child = <span class="literal">NULL</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dfs(temp -&gt; child, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　然后，我脑抽地以为能让样例通过的功劳仅仅是因为修改了【二号点】，<strong>就顺手删除了【一号点】处的if判断句</strong>。当我兴高采烈地提交代码，却遇到了第二次 <a href="https://leetcode.com/submissions/detail/364783208/" target="_blank" rel="noopener">Runtime Error</a>，这次就非常棘手，因为测试数据太长了，很难找出代码是在哪里出错了。又沉下心思考了一会儿，想起了我对于【一号点】的智障操作，仔细思索发现【一号点】实际上是有重要作用的，所以就重新补上了【一号点】的if语句，再次提交，通过！唉，终于能长舒一口气……</p>
<p><strong>收获：</strong> </p>
<ul>
<li>警惕链表题中的“访问了空指针的成员”，时刻保持预防该错误发生</li>
</ul>
<p><strong>题外话：</strong><br>　　今总算下载到了《算法竞赛进阶指南》，在第一页前言里写道，毕业于北大的作者李煜东说自己“在大约一年半的时间里，刷了3000+道，成长为NOI金牌得主，并入选国家集训队”。看到这些，我不禁感到惭愧，所谓的“天才”也是靠自己拼搏的汗水才能赢得北大的录取、别人的羡慕，-<strong>他在不间断的情况下平均每天刷5.4道题，而我自己现在每天一道LeetCode还经常拖到最后才写</strong>……<br>　　突然想起来之前在b站关注了一个up主 Ronan0，她每天会上传自己刷美区LeetCode每日一题的录屏，不过我一直没怎么看。后来我发现，她每日会上传两个题的录屏，我就在好奇另一个题目她是按照什么顺序刷的。直到最近才发现，每天的第二道题目就是国区的每日一题。<br>　　虽然我一直很讨厌励志鸡汤，但刷ACM确实需要靠鸡汤来支撑，我记得以前就看过几篇ACM前辈们的励志经历，比如 kuangbin 那句 “人一我百，人十我万”。今天又被李煜东大佬的经历激励到了，决定从明天开始，即便做不到每天5道题的强度，但至少要开始每天刷美区国区2道每日一题！！！</p>
<hr>
<p>因为题目没有说nums中的数字连续的，所以不能用visited数组，需要用map来进行标记</p>
<p>以前知道在遍历map 的时候输出，今天知道了如何在遍历的时候修改</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Line 10: Char 21: warning: result of comparison against a string literal is unspecified (use strncmp instead) [-Wstring-compare]</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">" "</span>) &#123;</span><br><span class="line">                    ^  ~~~</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Line 9: Char 17: runtime error: negation of -2147483648 cannot be represented in type 'int'; cast to an unsigned type to negate this value to itself (solution.cpp)</span><br><span class="line">SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:<span class="number">18</span>:<span class="number">17</span></span><br></pre></td></tr></table></figure>
<p>空间换时间，记忆化搜索</p>
<p>2020.07.16<br>50-Pow(x, n)  题目顺序类别: July LeetCoding Challenge</p>
<p><strong>随记：</strong><br>　　题目意思很简单，就是求幂。当然，虽然题目没说，但面试的时候肯定不能直接就调用内置的pow()函数，这样做就没意思了。<br>　　首先，我直接就能想到的做法就是一个for循环n个x连续相乘，时间复杂度为$O(n)$。但我犹豫了一下，思考如果指数n为0.5、2.23这样的小数怎么办？过了一会儿，我才注意到预设的代码模板里输入的n的类型为int，那么，我就可以放心大胆地直接for循环了<figure class="highlight plain"><figcaption><span>Limit Exceeded](https://leetcode.com/submissions/detail/367462199/)……我这才注意到题目有写道，指数n的范围是$[-2^&#123;31&#125;,2^&#123;31&#125;-1]$。而造成这次TLE的数据中的指数为-2147483648，也就是$-2^&#123;31&#125;$。在时间复杂度为$O(n)$时，这组数据要进行21亿次操作，会超时是毋庸置疑的。那么应该怎样缩短时间呢？</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line">　　既然，时间复杂度要小于$O(n)$，那么很容易就想到另一个时间复杂度$O(log\ n)$，一想到$O(log\ n)$就会想到二分查找，而一想到二分查找，我就突然想起 2020.05.09 367-Valid Perfect Square 这道题目里手动实现 sqrt() 就是用二分查找来实现的。</span><br><span class="line">**题外话：** </span><br><span class="line">　　我突然发现我对高中知识已经遗忘太多了。例如，在思索本题的时候，我知道 $y = 2^x $ 的图像的样子，是单调递增的，但是随后我就在琢磨：该函数图像关于y轴对称的图像的表达式是什么来着？是 $y = -2^x $ 吗？不对，这是关于x轴对称。是 $y = (-2)^x $ 吗？也不对啊，负数的幂是一正一负交替的，不可能画出平滑的曲线。然后我去搜索“指数函数”才看到，高中学的指数函数有限定条件的：“**一般地，$y = a^x $函数(a为常数且以a&gt;0，a≠1)叫做指数函数，在$a^x$前的系数必须是数1**”。原来，这个a是不能小于0的，再往下看，才想起来，$y = 2^x $ 关于y轴对称的图像的表达式是$y = (\frac 1 2) ^x $ ，唉，真的老了，才过去四年啊……</span><br><span class="line"></span><br><span class="line">**收获：** 无</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">2020.07.21</span><br><span class="line">本来以为是字典树，然后看了看感觉用不上字典树。</span><br><span class="line">简单来说本题思路就是 dfs + visted数组，直接写了一遍，没有进行任何修改，测试样例全部通过。本来还激动地以为自己写出来的dfs代码有史以来第一次不作任何debug就能一遍过，结果却Wrong Answer，查错了三分钟，发现 `if(board[i][j] = word[0])` 这里本来应该是 `==` ，相当低级的错误，无语……修改后再提交，一遍过。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">2020.07.24</span><br><span class="line">797-All Paths From Source to Target 题目顺序类别: July LeetCoding Challenge</span><br><span class="line"></span><br><span class="line">**随记：**</span><br><span class="line">　　非常普通的dfs模板题，很快就写完了。但是测试样例的时候运行不出来结果，然后进行查错，写了一句printf输出dfs经历过的结点，发现是因为判断递归终点的if语句写错了，所以导致没有结果。修改后，提交通过。</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">//原代码</span><br><span class="line">if(index == nodeNum) &#123; //到达终点</span><br><span class="line">    ans.push_back(temp);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//修改后</span><br><span class="line">if(index == nodeNum - 1) &#123; //到达终点</span><br><span class="line">    ans.push_back(temp);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">**收获：** 无</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">2020.07.27</span><br><span class="line">797-All Paths From Source to Target 题目顺序类别: July LeetCoding Challenge</span><br><span class="line">Creating a new C++ subvector?</span><br><span class="line">https://stackoverflow.com/questions/9705441/creating-a-new-c-subvector</span><br><span class="line"></span><br><span class="line">vector不能用substr</span><br><span class="line">vector find不能返回下标</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">vector&lt;int&gt; newPostorder(postorder.end() - newInorderSize, postorder.end() - 1);</span><br><span class="line">vector&lt;int&gt; newPostorder(postorder.end() - 1 - newInorderSize, postorder.end() - 1);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">vector&lt;int&gt; newInorder(inorder.begin(), inorder.begin() + rootIndex - 1);</span><br><span class="line">vector&lt;int&gt; newInorder(inorder.begin(), inorder.begin() + rootIndex);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">Your input</span><br><span class="line">[&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;C&quot;,&quot;C&quot;,&quot;D&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]</span><br><span class="line">2</span><br><span class="line">Your stdout</span><br><span class="line">A B C A B C D E idle D E </span><br><span class="line">Your answer</span><br><span class="line">11</span><br><span class="line">Expected answer</span><br><span class="line">10</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">2020.07.29</span><br><span class="line">浪费时间画了半天，不会，只能直接看答案。</span><br><span class="line">压根就没想到是dp</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">2020。07.30</span><br><span class="line">感觉会用到字典树</span><br><span class="line">```C++</span><br><span class="line">Your input</span><br><span class="line">&quot;catsanddog&quot;</span><br><span class="line">[&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</span><br><span class="line">Your answer</span><br><span class="line">[&quot;cat sand dog&quot;,&quot;cat sand dog&quot;,&quot;cat s and dog&quot;,&quot;cat s and dog&quot;]</span><br><span class="line">Expected answer</span><br><span class="line">[&quot;cats and dog&quot;,&quot;cat sand dog&quot;]</span><br><span class="line"></span><br><span class="line">void dfs(TreeNode* root, string s, int sSize, int index, string sentence) &#123;</span><br><span class="line">    cout&lt;&lt;sentence&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    if(index == sSize) &#123;</span><br><span class="line">        sentence.pop_back();//去掉末尾的空格</span><br><span class="line">        ans.push_back(sentence);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int key = s[index] - &apos;a&apos;;</span><br><span class="line">    if(root -&gt; child[key] != NULL) &#123; </span><br><span class="line">        sentence += root -&gt; child[key] -&gt; ch;</span><br><span class="line">        if(root -&gt; child[key] -&gt; hasBeenEnd == 1) &#123;</span><br><span class="line">            sentence += &quot; &quot;;</span><br><span class="line">            dfs(head, s, sSize, index + 1, sentence);</span><br><span class="line">            sentence.pop_back();//</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dfs(root -&gt; child[key], s, sSize, index + 1, sentence);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">Your input</span><br><span class="line">&quot;catsanddog&quot;</span><br><span class="line">[&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</span><br><span class="line">Your answer</span><br><span class="line">[&quot;cat sand dog&quot;,&quot;cat sand do&quot;,&quot;cats and dog&quot;,&quot;cats and do&quot;]</span><br><span class="line">Expected answer</span><br><span class="line">[&quot;cats and dog&quot;,&quot;cat sand dog&quot;]</span><br><span class="line"></span><br><span class="line">void dfs(TreeNode* root, string s, int sSize, int index, string sentence) &#123;</span><br><span class="line">    cout&lt;&lt;sentence&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    if(index == sSize) &#123;</span><br><span class="line">        sentence.pop_back();//去掉末尾的空格</span><br><span class="line">        ans.push_back(sentence);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int key = s[index] - &apos;a&apos;;</span><br><span class="line">    if(root -&gt; child[key] != NULL) &#123; </span><br><span class="line">        sentence += root -&gt; child[key] -&gt; ch;</span><br><span class="line">        if(root -&gt; child[key] -&gt; hasBeenEnd == 1) &#123;</span><br><span class="line">            sentence += &quot; &quot;;</span><br><span class="line">            dfs(head, s, sSize, index + 1, sentence);</span><br><span class="line">            sentence.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(index + 1 &lt; sSize) //</span><br><span class="line">            dfs(root -&gt; child[key], s, sSize, index + 1, sentence);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">2020.08.02</span><br><span class="line">没想到官方是用的链表</span><br><span class="line"></span><br><span class="line">只看到一个人跟我思路一模一样</span><br><span class="line">https://leetcode-cn.com/problems/design-hashset/solution/kan-dao-fan-wei-zhi-jie-jiu-kai-pi-liao-yi-ge-1000/</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">2020.08.03</span><br><span class="line">经典c语言题目</span><br><span class="line">本来以为能一遍过</span><br><span class="line">测试样例 &lt;= 号 没写 =</span><br><span class="line">没考虑数字，只考虑字母，把数字和标点一块剔除了</span><br><span class="line">后来才看到题目里描述是alphanumeric characters</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line">2020.08.05</span><br><span class="line">大脑急速转动，这是创建一个对象，然后不断操作，就类似于acm里的输入多组数据</span><br><span class="line">尝试把child指针数组for循环初始化去掉，报错</span><br><span class="line">一模一样的代码又提交了一遍，成功了……</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">2020.08.06</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">Line 924: Char 34: runtime error: addition of unsigned offset to 0x603000000040 overflowed to 0x603000000034 (stl_vector.h)</span><br><span class="line">SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/8/../../../../include/c++/8/bits/stl_vector.h:933:34</span><br><span class="line">Runtime: N/A</span><br><span class="line">```</span><br><span class="line">cout输出了一下，发现是因为有的</span><br><span class="line"></span><br><span class="line">acm比赛中有什么好的思维题推荐？ - ftiasch的回答 - 知乎</span><br><span class="line">https://www.zhihu.com/question/319391435/answer/1030766962</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">2020.08.07</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">Line 25: Char 15: error: no matching member function for call to &apos;insert&apos;</span><br><span class="line">            m.insert(index, temp);</span><br><span class="line">            ~~^~~</span><br></pre></td></tr></table></figure></p>
<p>m[index] = temp;</p>
<p>If two nodes have the same position, then the value of the node that is reported first is the value that is smaller.</p>
<p>Input:<br>[0,8,1,null,null,3,2,null,4,5,null,null,7,6]<br>Output:<br>[[8],[0,3,6],[1,4,5],[7,2]]<br>Expected:<br>[[8],[0,3,6],[1,4,5],[2,7]]</p>
<p>for(auto iter = m.begin(); iter!= m.end(); iter++){<br>            sort(iter -&gt; second.begin(), iter -&gt; second.end());<br>            ans.push_back(iter -&gt; second);<br>}</p>
<p>Input:<br>[0,5,1,9,null,2,null,null,null,null,3,4,8,6,null,null,null,7]<br>Output:<br>[[7,9],[5,6],[0,2,4],[1,3],[8]]<br>Expected:<br>[[9,7],[5,6],[0,2,4],[1,3],[8]]</p>
<p>we report the values of the nodes in order from top to bottom (decreasing Y coordinates).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">2020.08.08</span><br><span class="line">437-Path Sum III  题目顺序类别: August LeetCoding Challenge</span><br><span class="line"></span><br><span class="line">**随记：**</span><br><span class="line">　　这道题初看很简单，最直接的做法就是双重dfs：首先进行dfs遍历每一个二叉树结点，在这个过程中把每一个结点当作一个新的二叉树的根结点，再次进行dfs寻找路径的数目，累加后就是最终答案。但是我想了一下感觉在有1000个结点的二叉树里这样做肯定会超时，于是就放弃了这种做法，去思考会不会是什么记忆化搜索或是dp的解法。想了很久都没想出来，没办法只能去看题解。</span><br><span class="line">　　万万没想到，题解区里的解法之一就是双重dfs。于是我又回头写了一遍双重dfs，测试通过，提交一遍过。我只能感叹，此题的数据量比想象中要小，数据强度太弱了……</span><br><span class="line">　　不过，在题解区中也看到了另一个用“前缀和”的做法，这种解法应该就是我预期的最佳解法(虽然我不会)。</span><br><span class="line"></span><br><span class="line">**收获：**</span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">(0, 1)(1, 0)</span><br><span class="line">(0, 2)(1, 1)(1, 1)</span><br><span class="line">(2, 1)</span><br></pre></td></tr></table></figure>
<hr>
<p>2020.08.11<br>我以为本来是递减序列就不用添加一个position变量了，实际上还是需要的<br>mid position<br>类似于dp中的某些问题</p>
<hr>
<p>全排列，感觉复杂度太高，放弃<br>过了一会儿看题目下方的提示，很诧异，但也照着思路写了<br>写代码的过程中才发觉，并不是全排列</p>
<hr>
<p>2020.08.15<br>贪心算法就是不太容易去证明为什么这样做是正确的，但是这么做就是对的，类似于“公理”这种感觉</p>
<hr>
<p>2020.08.16</p>
<p>突然发现有人在喷labuladong抄袭：</p>
<blockquote>
<p>抄都没有抄明白，还让别人“稍微思考一下呗”，你抄的时候“思考”过吗？如果没有真才实学，请不要写公众号、写题解误导别人，夸大其词只会让人厌烦，请离开 LeetCode 。<br>抄袭证据请见：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/</a> 题解的评论区。</p>
</blockquote>
<p>2021.01.08补记：<br>今天发现他出书了，就去豆瓣搜了一下，发现了这则评论</p>
<blockquote>
<p>靠各种翻抄英文题解不表明出处然后在github上和公众号圈粉，到现在大家都不知道作者究竟是什么背景，这也可以出书？？？力扣上网友的讨论，大家自己看吧<a href="https://leetcode-cn.com/circle/discuss/MKwnEl/" target="_blank" rel="noopener">https://leetcode-cn.com/circle/discuss/MKwnEl/</a></p>
</blockquote>
<p>在这个<a href="https://leetcode-cn.com/circle/discuss/MKwnEl/" target="_blank" rel="noopener">LeetCode讨论贴</a>里，发现他已经被骂爆了…… 同时，有人说“感谢 LeetCode 官方删除 labuladong 的题解”，我查证了一下，确实如此，比如上文2020.08.16的链接已经被删除了，所以抄袭这件事算是被官方认可了。</p>
<p>从我个人角度来看，实事求是地说，这人写的文章确实对我有帮助，文章中的错误、误导之处我暂时没看到，因为我只认真看过几篇文章。但此人没什么真才实学而且太“跳”(嚣张)了，所以他被锤我并不感到惋惜。</p>
<hr>
<p>2020.08.25<br>看了一眼，感觉有点像是“背包问题”，更何况本题的目的是“求最值”，所以八九不离十就是动态规划<br>但大脑一片空白，就只能去看答案了。<br>答案的思路就是动态规划+贪心<br><a href="https://leetcode-cn.com/problems/minimum-cost-for-tickets/solution/cdong-tai-gui-hua-cong-qian-xiang-hou-tui-dao-geng/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-cost-for-tickets/solution/cdong-tai-gui-hua-cong-qian-xiang-hou-tui-dao-geng/</a></p>
<hr>
<p><a href="https://blog.csdn.net/qq_35293120/article/details/107131629" target="_blank" rel="noopener">https://blog.csdn.net/qq_35293120/article/details/107131629</a></p>
<hr>
<p>2020.09.01<br>949-Largest Time for Given Digits 题目顺序类别: September LeetCoding Challenge<br><strong>随记：</strong><br>　　乍一看以为是个简单的模拟题，然后很快就想了一个思路：就是从左到右在每一位上挑选出尽可能大且符合要求的数字，最后组成一个符合规则的时间字符串。<br>　　第一版代码简单地写几个for循环就完成了，样例都过了，然而第一次提交<a href="https://leetcode.com/submissions/detail/389790795/" target="_blank" rel="noopener">Wrong Answer</a>，172个样例只通过了131个。我仔细看了一下，发现是第一版代码的思路中有考虑不周全的地方，补写了几行代码后写出第二版代码，测试通过了这个导致第一次Wrong Answer的样例 <code>[1,9,6,0]</code>。<br>　　再次提交第二版代码，结果又是<a href="https://leetcode.com/submissions/detail/389792413/" target="_blank" rel="noopener">Wrong Answer</a>，172个样例通过了169个。看似即将就到达胜利了，但是这一次我才惊觉，<strong>我整个的代码思路是有问题的</strong>：对于 <code>[2,0,6,6]</code> 这个样例，我的代码会先挑选出”20”作为小时，所以就只剩下”66”作为分钟，这种时间字符串显然是不合规定的，所以代码判断无法构成合法字符串，返回空串，然而实际上是可以组成答案 “06:26”。对于出现的这个问题，我无法通过“打补丁”的方式去修改出正确的代码。<br>　　本来是准备直接看答案的，但是在搜索题目的时候发现本题的难度是easy，这让我感到无语，觉得自己不能连一道easy都写不出来，就又回过头想了想，还真的想出来一个思路：因为输入的数据只有四个数字，所以可以<strong>进行暴力全排列，构造出所有合法的时间字符串，然后从中挑选出最大的那个</strong>，即为答案。<br>　　按照这个思路，重写了一份dfs代码，测试了导致第二次Wrong Answer的数据通过，然后第三次提交，通过。接着我就去题解区看别人的思路，发现本题居然只有暴力全排列这一种解法……这是我万万没想到的，因为我本以为会有更优美的解法，没想到还是这么简单粗暴，正如OI界的一句名言“暴力出奇迹”。<br>　　顺带一提，在测试代码的时候出现了一个bug，报错信息如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Line <span class="number">4</span>: Char <span class="number">25</span>: error: expected parameter declarator</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">                        ^</span><br></pre></td></tr></table></figure></p>
<p>然后搜索了一下，在这篇<a href="http://www.dtmao.cc/news_show_30716.shtml" target="_blank" rel="noopener">博文</a>里找到了答案，就是说：当vector以<strong>成员变量</strong>在class里出现时，不能以常规的方式去直接初始化vector的大小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改前</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我修改了这个bug后才想起来，在2020.05.30遇到过同样的问题，只不过当时选择的修改方式是：在class的成员变量里仅仅声明一个vector，然后在class的构造函数内用resize()去设置大小。</p>
<p><strong>收获：</strong></p>
<ul>
<li>回顾了在class里如何正确地设置成员变量vector的大小</li>
</ul>
<hr>
<p>2020.09.13<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AddressSanitizer:DEADLYSIGNAL</span><br><span class="line">=================================================================</span><br><span class="line">==<span class="number">33</span>==ERROR: AddressSanitizer: SEGV on unknown address <span class="number">0x000000000000</span> (pc <span class="number">0x000000385f52</span> bp <span class="number">0x7ffcc3f38df0</span> sp <span class="number">0x7ffcc3f38c80</span> T0)</span><br><span class="line">==<span class="number">33</span>==The signal is caused by a READ memory access.</span><br><span class="line">==<span class="number">33</span>==Hint: address points to the zero page.</span><br><span class="line">    #<span class="number">4</span> <span class="number">0x7f73ca74982f</span>  (/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>+<span class="number">0x2082f</span>)</span><br><span class="line">AddressSanitizer can <span class="keyword">not</span> provide additional info.</span><br><span class="line">==<span class="number">33</span>==ABORTING</span><br></pre></td></tr></table></figure></p>
<hr>
<p>2020.10.04<br>类似于 2020.07.08 记载过的<br>unordered_set 也无法存储 pair，要换用set</p>
<hr>
<p>2020.10.15<br>想到了环状替换的做法，也发现了那个特殊情况，即有时候会有循环现象，但是想了好久不知道怎么去处理那个特殊情况，也没有总结这个特殊情况的准确定义</p>
<p>看了题解才知道特殊情况的定义是 len % realMovement == 0</p>
<p>而且，题解里这个do-while循环结构，我印象中基本上没用过，不过我后来自己写的时候改写成while循环了，但是形式就没有do-while那么简洁，多了两行处理后续的代码</p>
<hr>
<p>2020.10.17<br>第一步只想到暴力，但肯定会超时<br>然后想到可能要用到滑动窗口，可我又不会，就想直接去看答案<br>当我差一点就要看答案的时候，突然想到可以用 map + substr 来做<br>缕清思路发现确实可行，写了一遍，提交通过了<br>去看题解，发现绝大部分都是跟我一样的思路，而且也没有发现预想中的滑动窗口的解法，看来是我多虑了</p>
<hr>
<p>2020.10.22<br>觉得第一版代码的这种做法虽然可以原地递归，形式上很简洁，但是没有进行剪枝<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root -&gt; left == <span class="literal">NULL</span> &amp;&amp; root -&gt; right == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> min(minDepth(root -&gt; left) + <span class="number">1</span>, minDepth(root -&gt; right) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>于是我又写了第二版代码就是额外写一个dfs函数，一遍过。只是不知道为什么，即使进行了剪枝但是耗时还是有点长</p>
<p>当我浏览题解区的时候，看了<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/li-jie-zhe-dao-ti-de-jie-shu-tiao-jian-by-user7208/" target="_blank" rel="noopener">这篇文章</a> ，才突然发觉我的第一版代码好像遗漏了一点什么</p>
<p>然后我就进行测试，果然，测试到第二个样例出错了。debug的时候发现，第一版代码少了一种情况——“只有一个孩子结点时”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root -&gt; left == <span class="literal">NULL</span> &amp;&amp; root -&gt; right == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root -&gt; left == <span class="literal">NULL</span> || root -&gt; right == <span class="literal">NULL</span>) <span class="comment">//之前少考虑了只有一个孩子的情况</span></span><br><span class="line">    <span class="keyword">return</span> minDepth(root -&gt; left) + minDepth(root -&gt; right) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> min(minDepth(root -&gt; left) + <span class="number">1</span>, minDepth(root -&gt; right) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>修改后提交通过，但耗时还是很长，算了不管耗时了</p>
<p>提交通过后，我想起来，其实之前遇到过类似的题目，在那时也陷入了同样的思维盲区，少考虑了“只有一个孩子结点”的情况。所以，<strong>以后遇到“叶子结点”相关的题目，一定要分为三种情况: 当前就是叶子结点、只有一个孩子结点、有两个孩子结点</strong></p>
<hr>
<p>2020.10.23<br>456-132 pattern<br>想了半天才写出来一个O(n)的解法</p>
<p>即先找最大值作为中间数，然后在后半段找次大值，接着在前半段找最小值</p>
<p>一提交，WrongAnswer</p>
<p>虽然通过了 87/96 个样例，貌似稍微修改一下就能全部通过了</p>
<p>但看了错误样例，才发现自己的思路从头开始就是错的，因为中间的那个数字不一定是整个数组中的最大值</p>
<p>想了一会儿没思路，就去看题解，发现通过率才28%…</p>
<hr>
<p>2020.10.30<br>673-Number of Longest Increasing Subsequence</p>
<p>最长上升子序列的个数</p>
<p>看了一会儿，不会，就去看答案了</p>
<p>看答案之前，我一直以为自己会求最长上升子序列的长度，只是不会求个数</p>
<p>看了答案才知道，我连第一步最长上升子序列都不会……</p>
<p>因为我看637题的时候，认为第一步求最长上升子序列的时间复杂度是$O(N)$</p>
<p>看到答案才发现，复杂度是$O(N^2)$，说明我连最基础的第一步都不会</p>
<hr>
<p>2020.11.04<br>310-Minimum Height Trees<br>暴力bfs写了一遍，统计以每一个结点为根时，树的height，然后找出最小的<br>提交 <code>65 / 68 test cases passed.  Time Limit Exceeded</code><br>超时就没办法了，所以直接去看答案了</p>
<hr>
<p>2020.11.06<br>1283-Find the Smallest Divisor Given a Threshold</p>
<p>一看到就能够感觉到是个二分查找，但是写的过程中碰到好多坑，最后非常艰难地独自写完了</p>
<p>1.数据类型<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> temp = <span class="number">0</span>; <span class="comment">//不知道为什么，如果这里用double，下面求和的结果永远是0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    temp = temp + <span class="built_in">ceil</span>(nums[i] / <span class="keyword">double</span>(mid));</span><br></pre></td></tr></table></figure></p>
<p>2.一直死循环，查了半天错才发现，改变 right 和 left 的语句的位置 写反了<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为本题里 【改变 right 和 left 的语句】的位置 和二分模板是相反的，导致我白白浪费了半个小时去debug……</span></span><br><span class="line"><span class="keyword">if</span>(temp &lt; threshold)</span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(temp &gt; threshold)</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>3.寻找左侧边界。一开始感觉是要找左侧边界，写着写着写着又感觉不需要，第一次提交 <a href="https://leetcode.com/submissions/detail/417643717/" target="_blank" rel="noopener">WrongAnswer</a> 后，根据打印出来的中间过程才发现不能直接返回mid，还是需要寻找左侧边界<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(temp == threshold)</span><br><span class="line">   <span class="comment">//return mid 不能直接返回，需要找到尽可能小的mid，即寻找左侧边界</span></span><br><span class="line">   right = mid - <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>4.排序后取最大值会增加耗时，找max的最佳方式是用*max_element(nums.begin(), nums.end())，它本质上就是二分查找。修改后耗时从 <code>96ms 16.62% --&gt; 60ms 91.69%</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sort(nums.begin(), nums.end());</span></span><br><span class="line"><span class="comment">//int right = nums[numsSize - 1];</span></span><br><span class="line"><span class="keyword">int</span> right =  *max_element(nums.begin(), nums.end()); <span class="comment">//看了答案之后，发现这样写会更快</span></span><br></pre></td></tr></table></figure></p>
<hr>
<p>2020.11.08<br>563-Binary Tree Tilt<br>dfs后续遍历 + 全局变量<br>本题不能原地递归，需要全局变量加以辅助</p>
<hr>
<p>2020.11.09<br>1026-Maximum Difference Between Node and Ancestor</p>
<p>dfs + 全局变量，到达终点后直接调用STL函数求vector的最大最小值，然后相减</p>
<p>但这样做耗时可能会长一些，因为STL求最值函数的原理好像是二分查找</p>
<p>我想过设置两个全局变量 maxOnPath minOnPath 随时进行更新，这样就不会有额外的时间消耗。但是在实践的时候发现有点问题，在下一层函数返回上一层函数的时候，maxOnPath minOnPath 的值并不是进入下一层函数之前的数值了，于是就舍弃这样的做法了。</p>
<p>看了答案才知道，第二种思路没问题，但是不能把 maxOnPath minOnPath 设置成全局变量，应该是作为参数层层传递，这样在返回上一层函数的时候，maxOnPath minOnPath 还能保持原样。这样就实现了一边进行dfs遍历，一边更新 maxOnPath minOnPath</p>
<p><strong>收获：</strong></p>
<ul>
<li>回顾了<a href="https://www.cnblogs.com/sword-/p/8036813.html" target="_blank" rel="noopener">C++中Vector求最大值最小值</a></li>
</ul>
<hr>
<p>2020.11.11<br>593-Valid Square</p>
<p>第一版代码很糟糕，只考虑了上下两边均水平的情况，提交出错才发现问题</p>
<p>判断 对角线相等 + 对角线垂直<br>存在两个问题：</p>
<ol>
<li>我采取的排序方式是横坐标从小到大，横坐标相等时纵坐标从大到小。列出了4种正方形的位置(上下两边均水平、上下顶点竖直、上顶点偏左、上顶点偏右)，但我写代码的时候脑子有点乱，感觉即使排序后也无法确定 1号点 的对角点 是几号</li>
<li>不知道 对角线垂直 怎么去解决，因为会存在对角线斜率不存在的情况(即对角线竖直状态)</li>
</ol>
<p>然后去看答案，官方题解的第二种方法是这样的：</p>
<ol>
<li>无论正方形的位置如何，每一种情况都是1号点对3号点，2号点对4号点。(虽然该题解的纵坐标是升序排列，跟我的排列相反，但也不影响这个结论的成立)</li>
<li>题解采取的判断方式是 对角线相等 + 四条边相等</li>
</ol>
<p>最后采用了<a href="https://leetcode-cn.com/problems/valid-square/solution/ji-suan-suo-you-dian-lian-qi-lai-de-bian-chang-cun/" target="_blank" rel="noopener">这篇题解</a>的思路，直接对正方形的六条连线进行操作。该解法并没有在官方题解中出现，是一种新的思路。</p>
<hr>
<p>2020.11.12<br>Permutations II</p>
<p>中间测试了一下 unordered_set 不能嵌套 vector，只能用 set<br>一遍过<br>别人都8ms我784ms，效率太低了</p>
<p>看答案，发现是因为我没有剪枝</p>
<hr>
<p>2020.11.12<br>116-Populating Next Right Pointers in Each Node<br>层序遍历的变式题，难度稍微增加了一点点，但总的来说还是很简单</p>
<p><strong>收获：</strong></p>
<ul>
<li>populate 在计算机专业术语中的意思是 “填充” (可在剑桥词典查到)</li>
</ul>
<hr>
<p>2020.11.14<br>458-poor pigs<br>你只有 10 只小白鼠和一星期的时间，如何检验出哪个瓶子里有毒药？ - 黄志聪的回答 - 知乎 <a href="https://www.zhihu.com/question/19676641/answer/12613290" target="_blank" rel="noopener">https://www.zhihu.com/question/19676641/answer/12613290</a></p>
<p>这个我看完后还是有点不明白</p>
<p><a href="https://blog.csdn.net/yan456jie/article/details/51135098" target="_blank" rel="noopener">https://blog.csdn.net/yan456jie/article/details/51135098</a><br>看到这篇博文里写 “最低位为1的1、3、5、7的药混合给第一只老鼠吃，老鼠如果死了，证明这四瓶一定有一瓶是毒药，则药的编号个位一定为1”，我才完全明白上文知乎的那个回答</p>
<p>1000桶水，其中一桶有毒，猪喝毒水后会在15分钟内死去，想用一个小时找到这桶毒水，至少需要几头猪？ - 苗华栋的回答 - 知乎 <a href="https://www.zhihu.com/question/60227816/answer/1274071217" target="_blank" rel="noopener">https://www.zhihu.com/question/60227816/answer/1274071217</a><br>这篇回答从<strong>信息论</strong>的角度来阐述该问题，相当硬核</p>
<hr>
<p>2020.11.15<br>Range Sum of BST</p>
<p>题意很简单，但是由于本题里的二叉树是BST，所以肯定要用到BST的性质，而不能简单地像处理普通二叉树那样无脑暴力遍历所有结点</p>
<p>不过，很快就想到了剪枝的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Line <span class="number">41</span>: Char <span class="number">5</span>: error: non-<span class="keyword">void</span> function does <span class="keyword">not</span> <span class="keyword">return</span> a value in all control paths [-Werror,-Wreturn-type]</span><br><span class="line">    &#125;</span><br><span class="line">    ^</span><br><span class="line"><span class="number">1</span> error generated.</span><br></pre></td></tr></table></figure>
<p>其实这也是个经常遇到的问题了，在此重新提及一下。</p>
<p>经常出现这种错误的代码特征如下：</p>
<ol>
<li>函数本身是非void函数，但是结尾却没有写return</li>
<li>那么写代码的时候为什么结尾没写return？是忘写了吗？</li>
<li>因为return <strong>全部</strong>都写在了 if-else 语句中了</li>
<li>并且 if-else 语句一般都是 if 语句 后接 else if 语句，并且整个if-else模块的最后没有 else 语句，就导致并不是所有的分支都有返回值，比如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i &gt; <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>解决方法一般有两种：</p>
<ol>
<li>创建一个新变量 ans，用 ans赋值语句 替换掉 if-else 模块中 return 语句，然后在函数的末尾 return ans;</li>
<li>把 if-else 模块改写为末尾带有 else语句 的模块，这样就能保证所有的分支都有返回值</li>
</ol>
<p>今天我就选择了方式2进行修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root -&gt; val &lt;= low) &#123; </span><br><span class="line">    <span class="keyword">int</span> rightValue = rangeSumBST(root -&gt; right, low, high);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root -&gt; val == low)</span><br><span class="line">        <span class="keyword">return</span> root -&gt;val + rightValue;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root -&gt; val &lt; low)</span><br><span class="line">        <span class="keyword">return</span> rightValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root -&gt; val &gt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> leftValue = rangeSumBST(root -&gt; left, low, high);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root -&gt; val == high)</span><br><span class="line">        <span class="keyword">return</span> root -&gt; val + leftValue;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root -&gt; val &gt; high)</span><br><span class="line">        <span class="keyword">return</span> leftValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> leftValue = rangeSumBST(root -&gt; left, low, high);</span><br><span class="line">    <span class="keyword">int</span> rightValue = rangeSumBST(root -&gt; right, low, high);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> root -&gt; val + leftValue + rightValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line"><span class="comment">//修改成</span></span><br><span class="line"><span class="keyword">if</span>(root -&gt; val &lt;= low) &#123; </span><br><span class="line">    <span class="keyword">int</span> rightValue = rangeSumBST(root -&gt; right, low, high);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root -&gt; val == low)</span><br><span class="line">        <span class="keyword">return</span> root -&gt;val + rightValue;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//if(root -&gt; val &lt; low) //1号点的位置</span></span><br><span class="line">        <span class="keyword">return</span> rightValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root -&gt; val &gt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> leftValue = rangeSumBST(root -&gt; left, low, high);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root -&gt; val == high)</span><br><span class="line">        <span class="keyword">return</span> root -&gt; val + leftValue;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//if(root -&gt; val &gt; high) //2号点的位置</span></span><br><span class="line">        <span class="keyword">return</span> leftValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> leftValue = rangeSumBST(root -&gt; left, low, high);</span><br><span class="line">    <span class="keyword">int</span> rightValue = rangeSumBST(root -&gt; right, low, high);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> root -&gt; val + leftValue + rightValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，我这个代码框架里，当代码进行到 1号点、2号点时，就已经完全保证了<br>else 和 else if(root -&gt; val &lt; low) 在此作用是相同的<br>else 和 else if(root -&gt; val &gt; high) 在此作用是相同的</p>
<p>我之所以写成 else if，只是为了让代码的含义清晰地展现出来</p>
<p>只不过我在写代码的时候没有想到，即便这两种代码的作用一模一样，但修改之前会报错，修改之后就能顺利运行。可能这就是“代码规范”吧</p>
<p>我这个代码也可以采用第一种解决方式——把所有的return用ans替代，统一在末尾返回 ans</p>
<hr>
<p>2020.11.16<br>Longest Mountain in Array</p>
<p>其实题目本身不算太复杂，但是额外添������制导致我不知道怎么去做了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Follow up:</span><br><span class="line">Can you solve it <span class="keyword">using</span> only one pass?</span><br><span class="line">Can you solve it in O(1) space?</span><br></pre></td></tr></table></figure>
<p>然后就直接去看题解了。有<a href="https://leetcode-cn.com/problems/longest-mountain-in-array/solution/zui-hao-li-jie-de-dong-tai-gui-hua-by-likeriver/" target="_blank" rel="noopener">一篇题解</a>(后来发现跟官方题解1一样)是采用了dp的做法，其实这种dp的思路我在思考的过程中想到了。</p>
<p>只不过，因为dp解法空间复杂度明显超过了O(1)，而且需要从头到尾、从尾到头扫描两次，不满足 “Can you solve it using only one pass?”</p>
<p>所以当时没有深入思考就放弃这一方向了，所以并没有把dp解法的完整思路构造出来。</p>
<p>最后提交的代码是参考这个模拟法的题解<br><a href="https://leetcode-cn.com/problems/longest-mountain-in-array/solution/yi-ci-sao-miao-mo-ni-fa-by-newgoer/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-mountain-in-array/solution/yi-ci-sao-miao-mo-ni-fa-by-newgoer/</a></p>
<hr>
<p>2020.11.18<br>858-Mirror Reflection</p>
<p>想到了模拟法，感觉好麻烦不不想写</p>
<p>隐隐觉得应该是有数学方法来解决本题的，但是想不出来</p>
<p>去看题解，果然就是这两种解法</p>
<p>数学法，主要思路就是找最小公倍数，我完全没有往这方面想过，太失败了……</p>
<hr>
<p>2020.11.19</p>
<p>这应该是我写算法题以来第三次遇到的括号匹配问题<br>第一次，大一暑假集训队，洛谷上的一道题，当时不会做<br>第二次，北理工保研机试，幸好考前在《王道机试》看过这类题，所以暴力通过了。后来发现是leetcode上的一道题，暴力法超时。</p>
<p>看到括号匹配问题，就要想到用栈和递归去解决</p>
<p>既然有经验了，所以本题就不难写</p>
<p>然而中途犯了两个错误，导致花费很多时间去debug</p>
<ol>
<li><p>特别弱智，忘了加引号，导致char变为int</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[index] &gt;= <span class="string">'0'</span> &amp;&amp; s[index] &lt;=<span class="number">9</span>)</span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[index] &gt;= <span class="string">'0'</span> &amp;&amp; s[index] &lt;= <span class="string">'9'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>我在样例 <code>s = &quot;3[a2[c]]&quot;</code> 的基础上，自创了一个更特殊的数据 <code>s = &quot;3[a2[c]def]&quot;</code>，但是输出总不对。后来发现，多写了一个if判断句，本题不需要这个判断 </p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(stk.empty())</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//if(stk.empty())</span></span><br><span class="line"><span class="comment">//因为 square brackets are well-formed，所以不存在括号不匹配，这个if判断不用写</span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><strong>收获：</strong></p>
<ul>
<li>well-formed (惯用语句、表达等)符合语法规则的; 语法正确的</li>
</ul>
<hr>
<p>2020.11.20</p>
<hr>
<p>2020.11.23</p>
<p>虽然写过 House Robber I &amp; House Robber II</p>
<p>我直到要用到dp，但是碰到本题还是脑袋空空</p>
<p>不知道如何去定义dp数组的结构</p>
<p>中途思考过用 pair 去捆绑 TreeNode* 和 newInfomation，然后再把pair放在dp数组中</p>
<p>但总感觉哪还是不太对，反转想到最后思维就混乱掉了</p>
<p>去看题解，发现本题所涉及的算法思想是“树形dp”</p>
<p>“树形dp”这个名词我之前见到过，但是从来没做过这类题，今天算是第一次遇到</p>
<p><a href="https://leetcode-cn.com/problems/house-robber-iii/solution/shu-xing-dp-ru-men-wen-ti-by-liweiwei1419/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber-iii/solution/shu-xing-dp-ru-men-wen-ti-by-liweiwei1419/</a></p>
<p>看到这篇题解，我明白为什么我做不出来了——因为本题的dp数组是二维的，而 House Robber I &amp; House Robber II 所用到的dp数组都是一维的，这种思维的跨越对我来说，很难在短时间内想出来</p>
<p>除此之外，虽然本题的dp数组是二维的，但在代码层面，实际上没有定义一个二维dp数组，而是采用了“返回一个数组”的形式</p>
<p>然而，我之前在c++从来就没写过，函数类型(也可以说 返回值)为数组的函数，所以根本就想不到去用过这种代码技巧。(查了一下才发现，原来是因为C++不允许直接返回一个数组(但是Java可以)，怪不得我从来没用过…… 不过，C++可以返回 vector 和 pair)</p>
<p><a href="https://leetcode-cn.com/problems/house-robber-iii/solution/san-chong-fang-fa-jie-jue-shu-xing-dong-tai-gui-hu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber-iii/solution/san-chong-fang-fa-jie-jue-shu-xing-dong-tai-gui-hu/</a></p>
<p>这篇题解很不错，由浅入深，讲述了三种解题思路</p>
<p>文中写道 “由于二叉树不适合拿数组当缓存，我们这次使用哈希表来存储结果”，<strong>看到这句话我才明白</strong>：为什么在我独自思考的过程中 “想把pair放在dp数组中，最后思维就混乱掉了” ？—— 因为dp数组的下标索引是1234这样的数字，而不是 TreeNode*，所以应该用 HashMap 来代替数组</p>
<hr>
<p>2020.11.24<br>Basic Calculator II</p>
<p>表达式计算，大一学的全忘了</p>
<p>复制粘贴提交了，考完托福后补</p>
<hr>
<p>2020.11.25<br>1015-Smallest Integer Divisible by K</p>
<p>想的时候感觉就是一道数学题，没什么思路，就直接去看题解了</p>
<p>看了题解，果然基本就是一道用代码解决的纯数学题，用不到任何常见的计算机领域的算法</p>
<p><a href="https://leetcode-cn.com/problems/smallest-integer-divisible-by-k/solution/javajie-fa-yi-ji-zheng-ming-de-si-lu-by-jiangzk/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/smallest-integer-divisible-by-k/solution/javajie-fa-yi-ji-zheng-ming-de-si-lu-by-jiangzk/</a></p>
<p>这篇题解的证明写的很好<br>证明过程不难理解，基本上就是我在《信息安全数学原理》学到的内容，可惜技艺不精，自己证不出来</p>
<p><a href="https://leetcode-cn.com/problems/smallest-integer-divisible-by-k/solution/qu-yu-by-mudawei/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/smallest-integer-divisible-by-k/solution/qu-yu-by-mudawei/</a></p>
<p>这篇题解提到了本题的一个隐藏知识点：除了2的倍数和5的倍数，其他的数都有可能成为111111这种形式的数的因子</p>
<hr>
<p>2020.11.26<br>395-Longest Substring with At Least K Repeating Characters<br>看了题目后就隐隐感觉是<strong>滑动窗口</strong>，可惜忘得差不多了，尝试写了一下不会</p>
<p>去看题解，果然就有用到滑动窗口的解法<br><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/c-hua-dong-chuang-kou-jie-fa-by-fan-fan-yang-zhou/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/c-hua-dong-chuang-kou-jie-fa-by-fan-fan-yang-zhou/</a></p>
<p>除此之外，题解区还有很多运用到<strong>分治思想</strong>的解法，值得学习</p>
<hr>
<p>2020.11.27<br>416-Partition Equal Subset Sum</p>
<p>第一版代码 dfs+剪枝<br>由于本题是个子集问题，所以是组合而不是排列<br>因此dfs里的for循环的起始点发生了改变，不再是<br><code>for(int i = 0; i &lt; numsSize; i++)</code><br>而应该是<br><code>for(int i = index; i &lt; numsSize; i++)</code></p>
<p>提交，超时。</p>
<p>我突发奇想，觉得本题可能是 sort + 二分，于是又写了第二版代码。提交，WrongAnswer，仅仅通过了一半数据，看到数据<code>[2,2,1,1]</code>才发现 sort + 二分 思路是完全错误的。</p>
<p>然后我才感觉本题好像本质上就是 选或不选，即背包问题。</p>
<p>可是我把背包问题的dp推导又忘光，就去看题解。主要的解法果然就是dp背包。</p>
<p>刷TPO去了，之后补</p>
<hr>
<p>2020.11.28<br>Sliding Window Maximum</p>
<p>看着是个滑动窗口就不想写，去看题解，发现竟然是个hard，幸好刚才没有浪费时间去写</p>
<hr>
<p>2020.11.29<br>Jump Game III</p>
<p>看着不太难，目测是个dfs/bfs，但今天心情不太好不想写</p>
<p>去看题解，果然就是个简单的dfs/bfs搜索</p>
<p>等之后心情好了再补吧</p>
<hr>
<p>2021.01.04<br>21-Merge Two Sorted Lists</p>
<p>将两个有序链表合并为一个有序链表</p>
<p>题目很简单，但有两个点需要去抉择<br>①直接合并两个链表，还是开辟新空间合并两个链表？<br>②设置or不设置一个内容为空的头结点？</p>
<p>我采取了 ①-2 、 ②-2 的方式，官方题解里的迭代法采取的是 ①-1 、 ②-1 的方式</p>
<p>一开始，我还以为只需要设置一个 ListNode*指针 就行，后来才发觉一个不够需要两个，一个指针作为新链表的开头，用于return，另一个则作为迭代器，不断地在链表移动。</p>
<p>因为我没有设置一个内容为空的伪头结点，所以代码部分要对第一个结点，即真头结点，进行特殊处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ListNode* iter = <span class="literal">NULL</span>;</span><br><span class="line">ListNode* ans = <span class="literal">NULL</span>;</span><br><span class="line">................</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(iter == <span class="literal">NULL</span>) &#123; <span class="comment">//头节点</span></span><br><span class="line">    iter = <span class="keyword">new</span> ListNode(minVal);</span><br><span class="line">    ans = iter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    iter -&gt; next = <span class="keyword">new</span> ListNode(minVal);</span><br><span class="line">    iter = iter -&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以我的代码直接return ans，头结点；而官方题解return  prehead.next，即伪头结点的下一个结点</p>
<p>我代码里比较蠢的一点是，当一个链表已经被合并完后，因为我是通过开辟新空间来创造新链表，所以我需要继续原有的循环</p>
<p>然而，按照官方题解里原地合并(in-place)的思路，直接将新链表的末尾指向未合并完的链表即可</p>
<p>除了迭代法，官方题解还给出另一种解法，递归法，以后有时间再补吧</p>
<hr>
<p>2021.01.05<br>82-Remove Duplicates from Sorted List II</p>
<p>比较简单的一道题目，只不过好久没写题了，我在遍历链表的问题上纠结了一会儿，纠结到底是 <code>while(iter != NULL)</code> 还是 <code>while(iter -&gt; next !=)</code> 之类的问题</p>
<p>我的思路是，先遍历一遍链表，在map中作记录，然后找到新链表的头结点，最后在新链表上逐步增加结点，整体的流程采用的是循环迭代</p>
<p>看了答案我才发现我写复杂了，因为题目给出的原始链表是<strong>已排序过的</strong>，所以<strong>重复出现过的某种数字必然是相邻的</strong>，根据这个特点，就无需额外用map来判断某个value是否重复出现过</p>
<p>很多答案采用了递归法，以后有时间再补</p>
<hr>
<p>2021.01.06<br>Kth Missing Positive Number</p>
<p>直接用map，简单粗暴，当然时间复杂度会很高</p>
<p>更高效的方法以后再补吧</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2020/04/02/LeetCode刷题记录/">LeetCode刷题记录</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 Mondobongo 的个人博客">Mondobongo</a></p>
        <p><span>发布时间:</span>2020-04-02, 23:45</p>
        <p><span>最后更新:</span>2021-01-08, 14:32</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2020/04/02/LeetCode刷题记录/" title="LeetCode刷题记录">https://mondobongoo.github.io/2020/04/02/LeetCode刷题记录/</a>
            <span class="copy-path" data-clipboard-text="原文: https://mondobongoo.github.io/2020/04/02/LeetCode刷题记录/　　作者: Mondobongo" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>

    
    <nav id="article-nav">
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2019/03/15/数据范围导致的循环问题/">
                    数据范围导致的循环问题
                </a>
            </div>
        
    </nav>

  
</article>






    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"true"];
    </script>





    




    <div class="scroll" id="post-nav-button">
        
            <a href="/" title="回到主页"><i class="fa fa-home"></i></a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2019/03/15/数据范围导致的循环问题/" title="下一篇: 数据范围导致的循环问题">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/02/LeetCode刷题记录/">LeetCode刷题记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/15/数据范围导致的循环问题/">数据范围导致的循环问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/01/修改hexo字体大小与文字溢出边框问题/">修改hexo字体大小与CSS文字溢出边框问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/10/BUG记录之JSP篇/">BUG记录之JSP篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/25/记录一次令人崩溃、气得想撞墙的Tomcat环境启动过程/">记录一次令人崩溃、气得想撞墙的Tomcat环境启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/09/不吐不快——吐槽Tomcat 和 Eclipse 相关联过程中遇到的坑/">不吐不快——吐槽Tomcat与Eclipse相关联过程中遇到的坑</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/18/汇编语言环境搭建-输出-Hello-World/">汇编语言环境搭建&&输出'Hello World'</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/01/废话一箩筐/">废话一箩筐</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/24/codeforces-862B-Mahmoud-and-Ehab-and-the-bipartiteness/">codeforces-862B Mahmoud and Ehab and the bipartiteness</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/24/hihocoder-1121 二分图的判定/">hihocoder-1121 二分图的判定</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/24/简述二分图/">简述二分图</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/23/continue语句在while和for中用法的差别/">continue语句在while和for中用法的差别</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/19/对克鲁斯卡尔算法的深度理解/">对克鲁斯卡尔算法的深度理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/14/利用vector实现邻接表建图/">利用vector实现邻接表建图</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017-2021 Mondobongo
            </div>
            <div class="footer-right">
                鲜衣怒马少年时 <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
             github: ".github-widget a", 
            
             post: ".article-entry a[href]", 
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
	<!-- 页面点击小红心 -->
	<script type="text/javascript" src="/js/love.js"></script>
</body>
</html>

